package org.mpisws.jmc.checker;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.mpisws.jmc.runtime.HaltCheckerException;
import org.mpisws.jmc.runtime.HaltExecutionException;
import org.mpisws.jmc.runtime.HaltTaskException;
import org.mpisws.jmc.runtime.JmcRuntime;
import org.mpisws.jmc.runtime.JmcRuntimeConfiguration;
import org.mpisws.jmc.runtime.RuntimeEvent;
import org.mpisws.jmc.runtime.RuntimeEventType;

/**
 * The JmcModelChecker class is responsible for managing the model checking process. It uses a
 * JmcCheckerConfiguration to configure the process and a JmcTestTarget to specify the program under
 * test.
 */
public class JmcModelChecker {

    private static final Logger LOGGER = LogManager.getLogger(JmcModelChecker.class);

    private final JmcCheckerConfiguration config;

    /** Constructs a new JMC model checker with the default configuration. */
    public JmcModelChecker() {
        this(new JmcCheckerConfiguration.Builder().build());
    }

    /**
     * Constructs a new JMC model checker with the given configuration.
     *
     * @param config the configuration to use
     */
    public JmcModelChecker(JmcCheckerConfiguration config) {
        this.config = config;
    }

    /**
     * Checks the given test target. No instrumentation involved
     *
     * @param target the test target to check
     * @return the report generated by the model checker
     */
    public JmcModelCheckerReport check(JmcTestTarget target) {
        JmcRuntimeConfiguration runtimeConfig = config.toRuntimeConfiguration();
        JmcRuntime.setup(runtimeConfig);
        JmcModelCheckerReport report = new JmcModelCheckerReport();
        Long startTime = System.nanoTime();
        int numIterations = config.getNumIterations();
        int g = 0;
        try {
            for (int i = 0; i < numIterations; i++) {
                try {
                    JmcRuntime.initIteration(i);
                    target.invoke();
                    RuntimeEvent mainEndEvent =
                            new RuntimeEvent.Builder()
                                    .type(RuntimeEventType.FINISH_EVENT)
                                    .taskId(1L)
                                    .build();
                    JmcRuntime.updateEvent(mainEndEvent);
                    // TODO :: For debugging
                    /*System.out.println("[JMC MC] : The " + i + "th iteration is completed");*/
                    JmcRuntime.resetIteration(i);
                    g++;
                } catch (HaltTaskException e) {
                    LOGGER.debug(
                            "Halting execution: {} due to main thread halted: {}",
                            i,
                            e.getMessage());
                    break;
                } catch (HaltExecutionException e) {
                    LOGGER.error("Halting execution: {} due to exception: {}", i, e.getMessage());
                    break;
                } catch (AssertionError e) {
                    LOGGER.error("Assertion error in iteration {}: {}", i, e.getMessage());
                    break;
                }
            }
        } catch (HaltCheckerException e) {
            if (e.isOkay()) {
                LOGGER.info("Model checking completed successfully.");
            } else {
                LOGGER.info("Model checking failed: {}", e.getMessage());
                // TODO :: For debugging
                System.out.println("[JMC MC] : Model checking failed: " + e.getMessage());
                System.exit(1);
            }
        } finally {
            Long endTime = System.nanoTime();
            JmcRuntime.tearDown();
            // TODO :: For debugging
            System.out.println("[JMC MC] : The model checking time is: " + (endTime - startTime));
            System.out.println("[JMC MC] : The number of graphs : " + g);
            report.setTotalTimeMillis(endTime - startTime);
        }
        return report;
    }
}
