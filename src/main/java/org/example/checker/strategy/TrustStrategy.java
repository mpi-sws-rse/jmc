package org.example.checker.strategy;


import dpor.Trust;
import executionGraph.CO;
import executionGraph.ExecutionGraph;
import executionGraph.Node;
import org.example.checker.SearchStrategy;
import org.example.runtime.RuntimeEnvironment;
import programStructure.*;
import kotlin.Pair;

import java.io.*;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class TrustStrategy implements SearchStrategy {

    public Trust trust;

    // @param mcGraphs : is used to store the execution graphs that are generated by the model checker(@trust).
    public List<ExecutionGraph> mcGraphs;

    // @param currentGraph : is used to store the current execution graph.
    public ExecutionGraph currentGraph;

    // @param guidingActivate : is used to indicate whether the guiding execution graph is available or not.
    private boolean guidingActivate = false;

    // @param guidingExecutionGraph : is used to store the guiding execution graph.
    private ExecutionGraph guidingExecutionGraph;

    // @param guidingNode : is used to store the current node of the guiding execution graph.
    private Node guidingNode;

    // @param guidingThread : is used to store the current active thread of the guiding execution graph.
    private int guidingThread;

    // @param guidingEvents : is used to store the events that are available in the guiding execution graph.
    private List<Event> guidingEvents;

    // @param guidingEvent : is used to store the current event of the guiding execution graph.
    private Event guidingEvent;

    public TrustStrategy() {
        initMcGraphs();
        initCurrentGraph();
        initTrust();
        initGuidingGraph();
    }

    private void initMcGraphs() {
        if (RuntimeEnvironment.mcGraphs == null){
            RuntimeEnvironment.mcGraphs = new ArrayList<>();
        }
        RuntimeEnvironment.tempMcGraphs = new ArrayList<>();
        mcGraphs = new ArrayList<>();
    }

    private void initCurrentGraph() {
        currentGraph = new ExecutionGraph();
        currentGraph.addRoot(new InitializationEvent());
    }

    private void initTrust() {
        trust = new Trust();
        trust.setGraphCounter(RuntimeEnvironment.numOfGraphs);
    }

    private void initGuidingGraph() {
        if (!RuntimeEnvironment.mcGraphs.isEmpty()) {
            loadGuidingGraph();
        } else {
            noGuidingGraph();
        }
    }

    // The following part is used to find the guiding events of the guiding execution graph.
    // The @guidingEvents constructs based on the @guidingExecutionGraph's @sc. Note that the @graphEvents
    // (G.E in the trust paper) and @eventsOrder (\geq_{G} in the trust paper) of the @guidingExecutionGraph
    // are not reliable to find the guiding events. Since a forward revisit can violate the happens-before
    // relation between the events of these two list.
    private void loadGuidingGraph() {
        System.out.println("[Scheduler Thread Message] : The RuntimeEnvironment has a guiding execution graph");
        guidingActivate = true;
        guidingExecutionGraph = RuntimeEnvironment.mcGraphs.remove(0);
        guidingNode = guidingExecutionGraph.getRoot();
        guidingThread = 0;
        guidingEvents = new ArrayList<>();
        findGuidingEvents();
        // TODO() : The following part will be removed in the future.
        System.out.println("[Debugging Message] : The guiding events are : ");
        for (Event event : guidingEvents) {
            System.out.println(event);
        }
    }

    // The following initialize the set of all events of the @trust object with the Initialization event.
    private void noGuidingGraph() {
        System.out.println("[Scheduler Thread Message] : The MCGraphs are empty");
        trust.getAllEvents().add(
                currentGraph.getRoot().getValue() // The initialization event
        );
    }

    /*
     * The following method is used to compute the ordered list of the guiding events based on the
     * @guidingExecutionGraph. Base on the @sc of the @guidingExecutionGraph, it finds the order of the events that if
     * it picks the first event, the next event does not have any left hand side in the @sc of the
     * @guidingExecutionGraph except the first event
     */
    public void findGuidingEvents() {
        List<Event> freeEvents = new ArrayList<>();
        freeEvents.add(guidingNode.getValue());
        List<Event> candidateEvents = guidingExecutionGraph.getGraphEvents();
        candidateEvents.remove(guidingNode.getValue());
        while (candidateEvents.size() != 0) {
            List<Event> copyOfCandidateEvents = new ArrayList<>(candidateEvents);
            for (Event event : copyOfCandidateEvents) {
                boolean isValidEvent = true;
                for (Pair<Event, Event> pair : guidingExecutionGraph.getSc()) {
                    if (pair.getSecond().equals(event) && !freeEvents.contains(pair.getFirst())) {
                        isValidEvent = false;
                        break;
                    }
                }
                if (isValidEvent) {
                    freeEvents.add(event);
                    candidateEvents.remove(event);
                }
            }
        }
        guidingEvents.addAll(freeEvents);
        guidingEvents.remove(0);
    }

    /**
     * This method represents the required strategy for the next start event.
     *
     * @param calleeThread is the thread that is going to be started.
     * @param callerThread is the thread that is going to call the start method of the calleeThread.
     */
    @Override
    public void nextStartEvent(Thread calleeThread, Thread callerThread) {
        StartEvent st = RuntimeEnvironment.createStartEvent(calleeThread, callerThread);
        if (guidingActivate) {
            addEventToCurrentGraph(st);
        } else {
            passEventToTrust(st);
        }
    }

    private void passEventToTrust(Event event) {
        List<Event> tempEventList = new ArrayList<>();
        tempEventList.add(event);
        trust.setAllGraphs(new ArrayList<>());
        trust.visit(currentGraph, tempEventList);
    }

    private void addEventToCurrentGraph(Event event) {
        currentGraph.addEvent(event);
    }

    /**
     * This method represents the required strategy for the next enter monitor event.
     *
     * @param thread  is the thread that is going to enter the monitor.
     * @param monitor is the monitor that is going to be entered by the thread.
     */
    @Override
    public void nextEnterMonitorEvent(Thread thread, Object monitor) {
        System.out.println("[Scheduler Thread Message] : This version of Trust does not support the enter monitor event");
        System.exit(0);
    }

    /**
     * This method represents the required strategy for the next exit monitor event.
     *
     * @param thread  is the thread that is going to exit the monitor.
     * @param monitor is the monitor that is going to be exited by the thread.
     */
    @Override
    public void nextExitMonitorEvent(Thread thread, Object monitor) {
        System.out.println("[Scheduler Thread Message] : This version of Trust does not support the exit monitor event");
        System.exit(0);
    }

    /**
     * This method represents the required strategy for the next join event.
     *
     * @param joinReq is the thread that is going to join another thread.
     * @param joinRes is the thread that is going to be joined by another thread.
     */
    @Override
    public void nextJoinEvent(Thread joinReq, Thread joinRes) {
        if (guidingActivate) {
            addEventToCurrentGraph(RuntimeEnvironment.createJoinEvent(joinReq, joinRes));
        } else {
            passEventToTrust(RuntimeEnvironment.createJoinEvent(joinReq, joinRes));
        }
    }

    @Override
    public Thread nextJoinRequest(Thread joinReq, Thread joinRes) {
        if (guidingActivate) {
            nextJoinEvent(joinReq, joinRes);
            return joinReq;
        } else {
            RuntimeEnvironment.joinRequest.put(joinReq, joinRes);
            return pickNextRandomThread();
        }
    }

    /**
     * This method represents the required strategy for the next read event.
     *
     * @param readEvent is the read event that is going to be executed.
     */
    @Override
    public void nextReadEvent(ReadEvent readEvent) {
        if (guidingActivate) {
            addEventToCurrentGraph(readEvent);
            addRfEdgeToCurrentGraph(readEvent);
        } else {
            passEventToTrust(readEvent);
            updateCurrentGraph(readEvent);
        }
    }

    private void addRfEdgeToCurrentGraph(ReadEvent readEvent) {
        readEvent.setRf(findRfEdge((ReadEvent) guidingEvent));
    }

    private ReadsFrom findRfEdge(ReadEvent readEvent) {
        ReadsFrom rf = null;
        if (readEvent.getRf() instanceof InitializationEvent) {
            rf = (ReadsFrom) currentGraph.getEventsOrder().get(0);
        } else {
            WriteEvent tempWrite = (WriteEvent) readEvent.getRf();
            for (Event event : currentGraph.getEventsOrder()) {
                ThreadEvent tempThreadEvent = (ThreadEvent) event;
                if (tempThreadEvent.getTid() == tempWrite.getTid() &&
                        tempThreadEvent.getSerial() == tempWrite.getSerial() &&
                        tempThreadEvent.getType() == EventType.WRITE) {
                    rf = (ReadsFrom) event;
                    break;
                }
            }
        }
        return rf;
    }

    private void updateCurrentGraph(ThreadEvent threadEvent) {
        List<ExecutionGraph> newGraphs = trust.getAllGraphs();
        if (newGraphs.size() == 1) {
            System.out.println("[Scheduler Thread Message] : There is only one new graph");
            currentGraph = newGraphs.get(0);
        } else if (newGraphs.size() > 1) {
            findExtendingGraph(newGraphs, threadEvent);
        } else {
            int numOfGraphs = trust.getGraphCounter() + 1;
            trust.setGraphCounter(numOfGraphs);
            currentGraph.visualizeGraph(numOfGraphs);
            System.out.println("[Scheduler Thread Message] : There is no new graph from model checker");
            System.out.println("[Scheduler Thread Message] : visited full execution graph G_" + numOfGraphs);
        }
    }

    // here we want to find a graph which its @eventsOrder is equal to the @eventsOrder of SchedulerThread
    // and for each pair in the @sc of the graph, the left element is not equal to the @RuntimeEnvironment.MCEvent
    public void findExtendingGraph(List<ExecutionGraph> newGraphs, ThreadEvent threadEvent) {
        mcGraphs.addAll(newGraphs);
        for (ExecutionGraph graph : newGraphs) {
            System.out.println("[Debugging Message] : The new graph is : " + graph.getId());
            boolean isValidGraph = true;
            for (Pair<Event, Event> pair : graph.getSc()) {
                if (pair.component1().getType() == threadEvent.getType()) {
                    ThreadEvent leftHandSide = (ThreadEvent) pair.component1();
                    if (leftHandSide.getTid() == threadEvent.getTid() &&
                            leftHandSide.getSerial() == threadEvent.getSerial()) {
                        isValidGraph = false;
                        break;
                    }
                }
            }
            if (isValidGraph) {
                currentGraph = graph;
                mcGraphs.remove(graph);
                break;
            }

        }
        System.out.println("[Scheduler Thread Message] : The chosen graph is : " + currentGraph.getId());
        currentGraph.printSc();
        currentGraph.printGraph();
        currentGraph.printEvents();
        currentGraph.getEventsOrder();
    }

    /**
     * This method represents the required strategy for the next write event.
     *
     * @param writeEvent is the write event that is going to be executed.
     */
    @Override
    public void nextWriteEvent(WriteEvent writeEvent) {
        if (guidingActivate) {
            addEventToCurrentGraph(writeEvent);
        } else {
            passEventToTrust(writeEvent);
            updateCurrentGraph(writeEvent);
        }
    }

    /**
     * This method represents the required strategy for the next finish event.
     *
     * @param thread is the thread that is going to be finished.
     */
    @Override
    public void nextFinishEvent(Thread thread) {
        FinishEvent finishEvent = RuntimeEnvironment.createFinishEvent(thread);
        if (guidingActivate) {
            addEventToCurrentGraph(finishEvent);
            analyzeSuspendedThreadsForJoin(thread);
        } else {
            passEventToTrust(finishEvent);
            analyzeSuspendedThreadsForJoin(thread);
        }
    }

    @Override
    public Thread nextFinishRequest(Thread thread) {
        if (guidingActivate) {
            nextFinishEvent(thread);
            return pickNextGuidedThread();
        } else {
            nextFinishEvent(thread);
            return pickNextRandomThread();
        }
    }

    public Thread pickNextGuidedThread() {
        if(!guidingEvents.isEmpty()) {
            guidingEvent = guidingEvents.remove(0);
            if (guidingEvent instanceof StartEvent) {
                // Check the sc of the guidingExecutionGraph
                // for each pair in the @sc of the graph, if the right element is equal to the @guidingEvent, get the left element
                // here is the code for the above description
                for (Pair<Event, Event> pair : guidingExecutionGraph.getSTs()) {
                    if (pair.component2().equals(guidingEvent)) {
                        guidingThread = ((ThreadEvent) pair.component1()).getTid();
                        break;
                    }
                }
            } else {
                guidingThread = ((ThreadEvent) guidingEvent).getTid();
            }
            System.out.println(guidingEvent);
            System.out.println("[Scheduler Thread Message] : Thread-"+guidingThread+ " is selected to run");
            for (Thread thread : RuntimeEnvironment.readyThreadList) {
                System.out.println("Name : "+thread.getName() + " Id : "+RuntimeEnvironment.threadIdMap.get(thread.getId()));
            }
            System.out.println("[Debugging Message] : "+guidingThread);
            System.out.println("[Debugging Message] : "+RuntimeEnvironment.threadObjectMap);
            System.out.println("[Debugging Message] : "+RuntimeEnvironment.threadObjectMap.get((long) guidingThread));
            return RuntimeEnvironment.threadObjectMap.get((long) guidingThread);
        } else {
            System.out.println("[Scheduler Thread Message] : The guidingEvents is empty");
            System.out.println("[Scheduler Thread Message] : The currentGraph events are as follows");
            currentGraph.getGraphEvents().forEach(event -> System.out.println(event));
            System.out.println("[Scheduler Thread Message] : The guidingExecutionGraph events are as follows");
            guidingExecutionGraph.getEventsOrder().forEach(event -> System.out.println(event));
            // Adding Cos
            List<CO> newCOs = new ArrayList<>();
            for (CO co : guidingExecutionGraph.getCOs() ) {
                //System.out.println("[Debugging Message] : The co is : "+co);
                if (co.getFirstWrite() instanceof InitializationEvent){
                    ReadsFrom firstWrite = (ReadsFrom) currentGraph.getGraphEvents().get(0);
                    WriteEvent secondWrite = null;
                    for (Event event : currentGraph.getGraphEvents()) {
                        if (event instanceof WriteEvent){
                            WriteEvent writeEvent = (WriteEvent) event;
                            //System.out.println("[Debugging Message] : The writeEvent is : "+writeEvent);
                            if (writeEvent.getTid() == co.getSecondWrite().getTid() &&
                                    writeEvent.getSerial() == co.getSecondWrite().getSerial()){
                                secondWrite = writeEvent;
                                CO newCo = new CO(firstWrite, secondWrite);
                                newCOs.add(newCo);
                                break;
                            }
                        }
                    }
                } else {
                    WriteEvent firstWrite = null;
                    WriteEvent secondWrite = null;
                    for (Event event : currentGraph.getGraphEvents()) {
                        if (event instanceof WriteEvent){
                            WriteEvent writeEvent = (WriteEvent) event;
                            //System.out.println("[Debugging Message] : The writeEvent is : "+writeEvent);
                            if (writeEvent.getTid() == ((WriteEvent) co.getFirstWrite()).getTid() &&
                                    writeEvent.getSerial() == ((WriteEvent) co.getFirstWrite()).getSerial()) {
                                firstWrite = writeEvent;
                                for (Event event2 : currentGraph.getGraphEvents()) {
                                    if (event2 instanceof WriteEvent){
                                        WriteEvent writeEvent2 = (WriteEvent) event2;
                                        //System.out.println("[Debugging Message] : The writeEvent is : "+writeEvent2);
                                        if (writeEvent2.getTid() == ((WriteEvent) co.getSecondWrite()).getTid() &&
                                                writeEvent2.getSerial() == ((WriteEvent) co.getSecondWrite()).getSerial()){
                                            secondWrite = writeEvent2;
                                            CO newCo = new CO(firstWrite, secondWrite);
                                            newCOs.add(newCo);
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            currentGraph.setCOs(newCOs);
            System.out.println("[Scheduler Thread Message] : The new COs are added to the currentGraph");
            currentGraph.getCOs().forEach(co -> System.out.println(co));
            System.out.println("[Scheduler Thread Message] : The old COs are as follows");
            guidingExecutionGraph.getCOs().forEach(co -> System.out.println(co));

            // adding STs
            Set<Pair<Event, Event>> newSTs = new HashSet<>();
            for (Pair<Event, Event> st : guidingExecutionGraph.getSTs()) {
                ThreadEvent threadEvent1 = null;
                ThreadEvent threadEvent2 = null;
                for (Event event : currentGraph.getGraphEvents()) {
                    if (event instanceof ThreadEvent) {
                        ThreadEvent tempThreadEvent = (ThreadEvent) event;
                        if (tempThreadEvent.getTid() == ((ThreadEvent) st.component1()).getTid() &&
                                tempThreadEvent.getSerial() == ((ThreadEvent) st.component1()).getSerial() &&
                                tempThreadEvent.getType() == (st.component1()).getType()) {
                            threadEvent1 = tempThreadEvent;
                        }
                        if (tempThreadEvent.getTid() == ((ThreadEvent) st.component2()).getTid() &&
                                tempThreadEvent.getSerial() == ((ThreadEvent) st.component2()).getSerial() &&
                                tempThreadEvent.getType() == (st.component2()).getType()) {
                            threadEvent2 = tempThreadEvent;
                        }
                    }
                }
                newSTs.add(new Pair<>(threadEvent1, threadEvent2));
            }
            currentGraph.setSTs(newSTs);
            System.out.println("[Scheduler Thread Message] : The new STs are added to the currentGraph");
            currentGraph.getSTs().forEach(st -> System.out.println(st));
            System.out.println("[Scheduler Thread Message] : The old STs are as follows");
            guidingExecutionGraph.getSTs().forEach(st -> System.out.println(st));

            // adding JTs
            Set<Pair<Event, Event>> newJTs = new HashSet<>();
            for (Pair<Event, Event> jt : guidingExecutionGraph.getJTs()) {
                ThreadEvent threadEvent1 = null;
                ThreadEvent threadEvent2 = null;
                for (Event event : currentGraph.getGraphEvents()) {
                    if (event instanceof ThreadEvent) {
                        ThreadEvent tempThreadEvent = (ThreadEvent) event;
                        if (tempThreadEvent.getTid() == ((ThreadEvent) jt.component1()).getTid() &&
                                tempThreadEvent.getSerial() == ((ThreadEvent) jt.component1()).getSerial() &&
                                tempThreadEvent.getType() == (jt.component1()).getType()) {
                            threadEvent1 = tempThreadEvent;
                        }
                        if (tempThreadEvent.getTid() == ((ThreadEvent) jt.component2()).getTid() &&
                                tempThreadEvent.getSerial() == ((ThreadEvent) jt.component2()).getSerial() &&
                                tempThreadEvent.getType() == (jt.component2()).getType()) {
                            threadEvent2 = tempThreadEvent;
                        }
                    }
                }
                newJTs.add(new Pair<>(threadEvent1, threadEvent2));
            }
            currentGraph.setJTs(newJTs);
            System.out.println("[Scheduler Thread Message] : The new JTs are added to the currentGraph");
            currentGraph.getJTs().forEach(jt -> System.out.println(jt));
            System.out.println("[Scheduler Thread Message] : The old JTs are as follows");
            guidingExecutionGraph.getJTs().forEach(jt -> System.out.println(jt));
            guidingActivate = false;
            return pickNextRandomThread();
        }
    }

    /**
     * This method prints the current execution trace.
     */
    @Override
    public void printExecutionTrace() {
        currentGraph.printGraph();
    }

    @Override
    public Thread pickNextThread() {
        if (guidingActivate) {
            return pickNextGuidedThread();
        } else {
            return pickNextRandomThread();
        }
    }

    /**
     * This method indicates whether the execution is done or not.
     *
     * @return true if the execution is done, otherwise false.
     */
    @Override
    public boolean done() {
        if (RuntimeEnvironment.tempMcGraphs.isEmpty()) {
            return true;
        } else {
            return false;
        }
    }

    public void saveGraphsToFile(List<ExecutionGraph> mcGraphs, String fileName) {
        try {
            FileOutputStream fileOut = new FileOutputStream(fileName);
            ObjectOutputStream out = new ObjectOutputStream(fileOut);
            out.writeObject(mcGraphs);
            out.close();
            fileOut.close();
        } catch (IOException i) {
            i.printStackTrace();
        }
    }

    public List<ExecutionGraph> loadGraphsFromFile(String fileName) {
        List<ExecutionGraph> mcGraphs = null;
        try {
            FileInputStream fileIn = new FileInputStream(fileName);
            ObjectInputStream in = new ObjectInputStream(fileIn);
            mcGraphs = (List<ExecutionGraph>) in.readObject();
            in.close();
            fileIn.close();
        } catch (IOException i) {
            i.printStackTrace();
            return null;
        } catch (ClassNotFoundException c) {
            System.out.println("Class not found");
            c.printStackTrace();
            return null;
        }
        return mcGraphs;
    }

    @Override
    public void saveExecutionState() {
        saveGraphsToFile(mcGraphs, "src/main/resources/ObjectStore/mcGraphs.obj");

        // for debugging purposes
        // TODO () : remove the following code
        for (ExecutionGraph graph : mcGraphs) {
            System.out.println("[Debugging Message] : The new graph is : "+graph.getId());
            graph.printSc();
        }

        List<ExecutionGraph> savedGraphs = loadGraphsFromFile("src/main/resources/ObjectStore/mcGraphs.obj");

        // for debugging purposes
        // TODO () : remove the following code
        for (ExecutionGraph graph : savedGraphs) {
            System.out.println("[Debugging Message] : The new graph is : "+graph.getId());
            graph.printGraph();
        }

        // for debugging purposes
        // TODO () : remove the following code
        if (!savedGraphs.isEmpty()){
            for (Event event : savedGraphs.get(0).getEventsOrder()) {
                if (event instanceof WriteEvent){
                    WriteEvent writeEvent = (WriteEvent) event;
                    System.out.println(writeEvent.component5().getClazzString());
                    System.out.println(writeEvent.component5().getFieldString());
                } else if (event instanceof ReadEvent){
                    ReadEvent readEvent = (ReadEvent) event;
                    System.out.println(readEvent.component6());
                }
            }
        }

        // Add the all elements of the @savedGraphs to the @RuntimeEnvironment.MCGraphs
        RuntimeEnvironment.tempMcGraphs.addAll(savedGraphs);
        RuntimeEnvironment.numOfGraphs = trust.getGraphCounter();
    }
}
