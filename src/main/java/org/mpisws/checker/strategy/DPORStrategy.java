package org.mpisws.checker.strategy;

import dpor.DPOR;
import executionGraph.CO;
import executionGraph.ExecutionGraph;
import executionGraph.Node;
import kotlin.Pair;
import org.mpisws.checker.SearchStrategy;
import org.mpisws.runtime.RuntimeEnvironment;
import org.mpisws.solver.SymbolicSolver;
import org.mpisws.symbolic.SymbolicOperation;
import programStructure.*;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;

public abstract class DPORStrategy implements SearchStrategy {

    /**
     * @property {@link #mcGraphs} is used to store the execution graphs that are generated by the model checker.
     */
    protected ArrayList<ExecutionGraph> mcGraphs;

    /**
     * @property {@link #currentGraph} is used to store the current execution graph.
     */
    protected ExecutionGraph currentGraph;

    /**
     * @property {@link #guidingActivate} is used to indicate whether the {@link #guidingExecutionGraph} is available or
     * not.
     */
    protected boolean guidingActivate = false;

    /**
     * @property {@link #guidingExecutionGraph} is used to store the guiding execution graph.
     */
    protected ExecutionGraph guidingExecutionGraph;

    /**
     * @property {@link #guidingNode} is used to store the current node of the {@link #guidingExecutionGraph}.
     */
    protected Node guidingNode;

    /**
     * @property {@link #guidingThread} is used to store the current active thread of the {@link #guidingExecutionGraph}.
     */
    protected int guidingThread;

    /**
     * @property {@link #guidingEvents} is used to store the events that are available in the {@link #guidingExecutionGraph}.
     */
    protected List<Event> guidingEvents;

    /**
     * @property {@link #guidingEvent} is used to store the current event of the {@link #guidingExecutionGraph}.
     */
    protected Event guidingEvent;

    /**
     * @property {@link #buggyTracePath} is used to store the path of the buggy trace file.
     */
    protected String buggyTracePath;

    /**
     * @property {@link #buggyTraceFile} is used to store the name of the buggy trace file.
     */
    protected String buggyTraceFile;

    /**
     * @property {@link #executionGraphsPath} is used to store the path of the execution graphs directory.
     */
    protected String executionGraphsPath;

    /**
     * @property {@link #solver} is keeping the reference to {@link RuntimeEnvironment#solver}
     */
    protected SymbolicSolver solver;

    /**
     * @property {@link #dpor} is used to store the dpor-based model checker object.
     */
    protected DPOR dpor;


    public DPORStrategy() {
        buggyTracePath = RuntimeEnvironment.buggyTracePath;
        buggyTraceFile = RuntimeEnvironment.buggyTraceFile;
        executionGraphsPath = RuntimeEnvironment.executionGraphsPath;
        solver = RuntimeEnvironment.solver;
        if (!Files.exists(Paths.get(executionGraphsPath))) {
            System.out.println("[DPOR Strategy Message] : Directory " + executionGraphsPath + " does not exist ");
            System.exit(0);
        }
        if (!Files.exists(Paths.get(buggyTracePath))) {
            System.out.println("[DPOR Strategy Message] : Directory " + buggyTracePath + " does not exist ");
            System.exit(0);
        }
        initMcGraphs();
        initCurrentGraph();
        initGuidingGraph();
    }

    /**
     * Initializes the model checker graphs list.
     * <p>
     * This method initializes the {@link RuntimeEnvironment#mcGraphs} list and {@link #mcGraphs} list.
     * </p>
     */
    private void initMcGraphs() {
        if (RuntimeEnvironment.mcGraphs == null) {
            RuntimeEnvironment.initGraphCollection();
        }
        mcGraphs = new ArrayList<>();
    }

    /**
     * Initializes the current execution graph.
     * <p>
     * This method initializes the {@link #currentGraph} with the {@link InitializationEvent}.
     * </p>
     */
    private void initCurrentGraph() {
        currentGraph = new ExecutionGraph();
        currentGraph.addRoot(new InitializationEvent());
    }

    /**
     * Initializes the guiding execution graph.
     * <p>
     * This method initializes the {@link #guidingExecutionGraph} if the {@link RuntimeEnvironment#mcGraphs} is not empty.
     * Otherwise, it initializes the {@link #dpor} object with the root event of the {@link #currentGraph}.
     * </p>
     */
    private void initGuidingGraph() {
        if (!RuntimeEnvironment.mcGraphs.isEmpty()) {
            loadGuidingGraph();
            System.out.println("[DPOR Message] : The guiding execution graph is loaded");
            System.out.println("[DPOR Message] : The guiding execution graph is : G_" + guidingExecutionGraph.getId());
            System.out.println("[DPOR Message] : The guiding ordered events are : ");
            int index = 1;
            for (Event event : guidingEvents) {
                System.out.println("[DPOR Message] : " + index + "-" + event);
                index++;
            }
        } else {
            //noGuidingGraph();
        }
    }

    /**
     * Loads the guiding execution graph.
     * <p>
     * This method loads the guiding execution graph from the first element of the {@link RuntimeEnvironment#mcGraphs}
     * list, sets the {@link #guidingActivate} to true, initializes the {@link #guidingNode} with the root of the
     * {@link #guidingExecutionGraph}, sets the {@link #guidingThread} to 0, and initializes the {@link #guidingEvents}.
     * </p>
     */
    private void loadGuidingGraph() {
        System.out.println("[DPOR Strategy Message] : The RuntimeEnvironment has a guiding execution graph");
        guidingActivate = true;
        guidingExecutionGraph = RuntimeEnvironment.mcGraphs.nextGraph();
        guidingNode = guidingExecutionGraph.getRoot();
        guidingThread = 0;
        guidingEvents = new ArrayList<>();
        findGuidingEvents();
    }

    /**
     * Computes the ordered list of the guiding events based on the guiding execution graph.
     */
    abstract void findGuidingEvents();

    /**
     * Adds the given event to the current graph.
     * <p>
     * This method adds the event to the current graph. It sets the {@link #currentGraph} with the given event.
     * </p>
     *
     * @param event is the event that is going to be added to the current graph.
     */
    protected void addEventToCurrentGraph(Event event) {
        currentGraph.insertEvent(event);
    }

    /**
     * Passes the given event to the {@link #dpor} model checker.
     * <p>
     * This method passes the event to the dpor model checker. It sets the {@link DPOR#getAllGraphs()} ()} with an
     * empty list to make sure that the {@link #dpor} model checker does not have any previous graphs. Then, it calls
     * the {@link DPOR#visit(ExecutionGraph, List)} method to visit the current graph with the given event.
     * </p>
     *
     * @param event is the event that is going to be passed to the {@link #dpor} model checker.
     */
    protected void passEventToDPOR(Event event) {
        List<Event> tempEventList = new ArrayList<>();
        tempEventList.add(event);
        dpor.setAllGraphs(new ArrayList<>());
        dpor.visit(currentGraph, tempEventList);
    }

    /**
     * Passes the given events to the {@link #dpor} model checker.
     *
     * @param events is the list of events that are going to be passed to the {@link #dpor} model checker.
     */
    protected void passEventToDPOR(List<Event> events) {
        dpor.setAllGraphs(new ArrayList<>());
        dpor.visit(currentGraph, events);
    }


    /**
     * Updates the current graph.
     * <p>
     * This method updates the {@link #currentGraph}. It sets the {@link #currentGraph} with the new graphs that are
     * available in the {@link DPOR#getAllGraphs()}. If there is only one new graph, it sets the {@link #currentGraph}
     * with the new graph. If there are more than one new graphs, it finds the extending graph. Otherwise, it creates a
     * new graph and sets the {@link #currentGraph} with the new graph.
     * </p>
     *
     * @param threadEvent is the thread event that is going to be executed.
     */
    protected void updateCurrentGraph(ThreadEvent threadEvent) {
        List<ExecutionGraph> newGraphs = dpor.getAllGraphs();
        if (newGraphs.size() == 1) {
            System.out.println("[DPOR Strategy Message] : There is only one new graph");
            currentGraph = newGraphs.get(0);
        } else if (newGraphs.size() > 1) {
            if (threadEvent.getType() == EventType.SYM_EXECUTION) {
                SymExecutionEvent symExecutionEvent = (SymExecutionEvent) threadEvent;
                findExtendingGraphOverSymbolicEvent(newGraphs, symExecutionEvent);
            } else {
                findExtendingGraph(newGraphs, threadEvent);
            }
        } else {
            int numOfGraphs = dpor.getGraphCounter() + 1;
            dpor.setGraphCounter(numOfGraphs);
            currentGraph.visualizeGraph(numOfGraphs, executionGraphsPath);
            System.out.println("[DPOR Strategy Message] : There is no new graph from model checker");
            System.out.println("[DPOR Strategy Message] : visited full execution graph G_" + numOfGraphs);
//            System.out.println("[DPOR Strategy Debugging Message] : The events of the visited graph are : ");
//            currentGraph.getGraphEvents().forEach(System.out::println);
//            System.out.println("[DPOR Strategy Debugging Message] : The COs of the visited graph are : ");
//            currentGraph.getCOs().forEach();
//            System.out.println("[DPOR Strategy Debugging Message] : The STs of the visited graph are : ");
//            currentGraph.getSTs().forEach(System.out::println);
//            System.out.println("[DPOR Strategy Debugging Message] : The JTs of the visited graph are : ");
//            currentGraph.getJTs().forEach(System.out::println);
//            System.out.println("[DPOR Strategy Debugging Message] : The TCs of the visited graph are : ");
//            currentGraph.getTCs().forEach(System.out::println);
//            System.out.println("[DPOR Strategy Debugging Message] : The events order of the visited graph are : ");
//            currentGraph.getEventsOrder().forEach(System.out::println);
        }
    }


    private void findExtendingGraphOverSymbolicEvent(List<ExecutionGraph> newGraphs, SymExecutionEvent symExecutionEvent) {
        for (ExecutionGraph graph : newGraphs) {
            ThreadEvent lastEvent = (ThreadEvent) graph.getGraphEvents().get(graph.getGraphEvents().size() - 1);
            SymExecutionEvent lastSymEvent = (SymExecutionEvent) lastEvent;
            if (lastSymEvent.getResult() == symExecutionEvent.getResult()) {
                currentGraph = graph;
                newGraphs.remove(graph);
                mcGraphs.addAll(newGraphs);
                System.out.println("[DPOR Strategy Message] : The chosen graph is : " + currentGraph.getId());
                break;
            }
        }
    }

    /**
     * Finds the extending graph of the current graph.
     * <p>
     * This method finds the extending graph of the current graph. It adds the new graphs to the {@link #mcGraphs} list.
     * Then, it iterates over the {@link ExecutionGraph#getSc()} of each new graph and checks whether the left hand side
     * of the pair is equal to the given thread event. If it is not equal, it sets the {@link #currentGraph} with the
     * new graph. Otherwise, it removes the new graph from the {@link #mcGraphs} list.
     * </p>
     *
     * @param newGraphs   is the list of new graphs that are going to be checked.
     * @param threadEvent is the thread event that is going to be checked.
     */
    private void findExtendingGraph(List<ExecutionGraph> newGraphs, ThreadEvent threadEvent) {

        newGraphs.stream()
                .filter(graph -> isValidGraph(graph, threadEvent))
                .findFirst()
                .ifPresent(graph -> {
                    currentGraph = graph;
                    newGraphs.remove(graph);
                });

        mcGraphs.addAll(newGraphs);

        System.out.println("[DPOR Strategy Message] : The chosen graph is : " + currentGraph.getId());
    }

    /**
     * Represents the required strategy for the next start event.
     * <p>
     * This method represents the required strategy for the next start event. It creates a {@link StartEvent} for the
     * corresponding starting a thread request of a thread. The created {@link StartEvent} is added to the
     * {@link #currentGraph} if the {@link #guidingActivate} is true. Otherwise, it passes the event to the {@link #dpor}
     * model checker.
     * </p>
     *
     * @param calleeThread is the thread that is going to be started.
     * @param callerThread is the thread that is going to call the start method of the calleeThread.
     */
    @Override
    public void nextStartEvent(Thread calleeThread, Thread callerThread) {
        StartEvent st = RuntimeEnvironment.createStartEvent(calleeThread, callerThread);
        RuntimeEnvironment.eventsRecord.add(st);
        if (guidingActivate) {
            addEventToCurrentGraph(st);
        } else {
            System.out.println("[DPOR Strategy Message] : The start event is passed to the model checker");
            passEventToDPOR(st);
            updateCurrentGraph(st);
        }
    }

    @Override
    public void nextMainStartEvent(MainStartEvent mainStartEvent) {
        RuntimeEnvironment.eventsRecord.add(mainStartEvent);
        if (guidingActivate) {
            addEventToCurrentGraph(mainStartEvent);
        } else {
            System.out.println("[DPOR Strategy Message] : The main start event is passed to the model checker");
            passEventToDPOR(mainStartEvent);
            updateCurrentGraph(mainStartEvent);
        }
    }

    /**
     * @param conAssumeEvent
     */
    @Override
    public void nextConAssumeRequest(ConAssumeEvent conAssumeEvent) {
        RuntimeEnvironment.eventsRecord.add(conAssumeEvent);
        if (guidingActivate) {
            addEventToCurrentGraph(conAssumeEvent);
        } else {
            System.out.println("[DPOR Strategy Message] : The concrete assume event is passed to the model checker");
            passEventToDPOR(conAssumeEvent);
            updateCurrentGraph(conAssumeEvent);
        }
    }

    /**
     * @param assumeBlockedEvent
     */
    @Override
    public void nextAssumeBlockedRequest(AssumeBlockedEvent assumeBlockedEvent) {
        RuntimeEnvironment.eventsRecord.add(assumeBlockedEvent);
        if (guidingActivate) {
            addEventToCurrentGraph(assumeBlockedEvent);
        } else {
            System.out.println("[DPOR Strategy Message] : The assume blocked event is passed to the model checker");
            passEventToDPOR(assumeBlockedEvent);
            updateCurrentGraph(assumeBlockedEvent);
        }
    }

    /**
     * Represents the required strategy for the next join event.
     * <p>
     * This method represents the required strategy for the next join event. It creates a {@link JoinEvent} for the
     * corresponding joining a thread request of a thread and records it. The created {@link JoinEvent} is added to the
     * {@link #currentGraph} if the {@link #guidingActivate} is true. Otherwise, it passes the event to the {@link #dpor}
     * model checker.
     * </p>
     *
     * @param joinReq is the thread that is going to join another thread.
     * @param joinRes is the thread that is going to be joined by another thread.
     */
    @Override
    public void nextJoinEvent(Thread joinReq, Thread joinRes) {
        JoinEvent joinEvent = RuntimeEnvironment.createJoinEvent(joinReq, joinRes);
        RuntimeEnvironment.eventsRecord.add(joinEvent);
        if (guidingActivate) {
            addEventToCurrentGraph(joinEvent);
        } else {
            passEventToDPOR(joinEvent);
        }
    }

    /**
     * Represents the required strategy for the next join request.
     * <p>
     * This method represents the required strategy for the next join request. It calls the
     * {@link #nextJoinEvent(Thread, Thread)} if the {@link #guidingActivate} is true. Otherwise, it puts the join request
     * and join response in the {@link RuntimeEnvironment#joinRequest} map and picks the next random thread.
     * </p>
     *
     * @param joinReq is the thread that is going to join another thread.
     * @param joinRes is the thread that is going to be joined by another thread.
     * @return the next thread that is going to be executed.
     */
    @Override
    public Thread nextJoinRequest(Thread joinReq, Thread joinRes) {
        if (guidingActivate) {
            nextJoinEvent(joinReq, joinRes);
            return joinReq;
        } else {
            RuntimeEnvironment.joinRequest.put(joinReq, joinRes);
            return pickNextReadyThread();
        }
    }

    /**
     * Represents the required strategy for the next finish event.
     * <p>
     * This method represents the required strategy for the next finish event. It creates a {@link FinishEvent} for the
     * corresponding finishing execution request of a thread and records it. The created {@link FinishEvent} is added to the
     * {@link #currentGraph} if the {@link #guidingActivate} is true. Otherwise, it passes the event to the {@link #dpor}
     * model checker. The method also analyzes the suspended threads for joining the finished thread.
     * </p>
     *
     * @param thread is the thread that is going to be finished.
     */
    @Override
    public void nextFinishEvent(Thread thread) {
        FinishEvent finishEvent = RuntimeEnvironment.createFinishEvent(thread);
        RuntimeEnvironment.eventsRecord.add(finishEvent);
        if (guidingActivate) {
            addEventToCurrentGraph(finishEvent);
            analyzeSuspendedThreadsForJoin(thread);
        } else {
            passEventToDPOR(finishEvent);
            analyzeSuspendedThreadsForJoin(thread);
        }
    }

    /**
     * Represents the required strategy for the next finish request.
     * <p>
     * This method represents the required strategy for the next finish request. It calls the
     * {@link #nextFinishEvent(Thread)} and picks the next thread based on the guiding execution graph if the
     * {@link #guidingActivate} is true. Otherwise, it picks the next random thread.
     * </p>
     *
     * @param thread is the thread that is going to be finished.
     * @return the next thread that is going to be executed.
     */
    @Override
    public Thread nextFinishRequest(Thread thread) {
        nextFinishEvent(thread);
        if (guidingActivate) {
            return pickNextGuidedThread();
        } else {
            return pickNextReadyThread();
        }
    }

    /**
     * Represents the required strategy for the next failure event.
     * <p>
     * This method represents the required strategy for the next failure event. It creates a {@link FailureEvent} for
     * the corresponding failing execution request of a thread and records it. The created {@link FailureEvent} is added
     * to the {@link #currentGraph} if the {@link #guidingActivate} is true. Otherwise, it passes the event to the
     * {@link #dpor} model checker.
     *
     * </p>
     *
     * @param thread is the thread that is going to be failed.
     */
    @Override
    public void nextFailureEvent(Thread thread) {
        FailureEvent failureEvent = RuntimeEnvironment.createFailureEvent(thread);
        RuntimeEnvironment.eventsRecord.add(failureEvent);
        if (guidingActivate) {
            addEventToCurrentGraph(failureEvent);
        } else {
            passEventToDPOR(failureEvent);
        }
    }

    /**
     * Represents the required strategy for the next deadlock event.
     * <p>
     * This method represents the required strategy for the next deadlock event. It creates a {@link DeadlockEvent} for
     * the corresponding deadlock between the threads and records it. The created {@link DeadlockEvent} is added
     * to the {@link #currentGraph} if the {@link #guidingActivate} is true. Otherwise, it passes the event to the
     * </p>
     *
     * @param thread is the thread that is going to be finished.
     */
    @Override
    public void nextDeadlockEvent(Thread thread) {
        DeadlockEvent deadlockEvent = RuntimeEnvironment.createDeadlockEvent(thread);
        RuntimeEnvironment.eventsRecord.add(deadlockEvent);
        if (guidingActivate) {
            addEventToCurrentGraph(deadlockEvent);
        } else {
            passEventToDPOR(deadlockEvent);
        }
    }

    /**
     * Represents the required strategy for the next symbolic operation request.
     * <p>
     * This method represents the required strategy for the next symbolic operation request. It calls the
     * {@link #handleGuidingSymbolicOperationRequest(Thread, SymbolicOperation)} if the {@link #guidingActivate} is true.
     * Otherwise, it calls the {@link #handleNewSymbolicOperationRequest(Thread, SymbolicOperation)}.
     * </p>
     *
     * @param symbolicOperation is the symbolic operation that is going to be executed.
     */
    @Override
    public void nextSymbolicOperationRequest(Thread thread, SymbolicOperation symbolicOperation) {
        if (guidingActivate) {
            handleGuidingSymbolicOperationRequest(thread, symbolicOperation);
        } else {
            handleNewSymbolicOperationRequest(thread, symbolicOperation);
        }
    }

    /**
     * Handles the new symbolic operation request.
     * <p>
     * This method handles the new symbolic operation request. It finds the dependent formulas of the given symbolic
     * operation. It updates the path symbolic operations with the given symbolic operation and thread. It creates a new
     * {@link SymExecutionEvent} with the given thread, the formula of the symbolic operation, and the negatable value.
     * Finally, it adds the created event to the {@link RuntimeEnvironment#eventsRecord} and passes the event to the dpor.
     * </p>
     *
     * @param symbolicOperation is the symbolic operation that is going to be added to the path symbolic operations.
     * @param thread            is the thread that is going to execute the symbolic operation.
     */
    public void handleNewSymbolicOperationRequest(Thread thread, SymbolicOperation symbolicOperation) {
        solver.computeNewSymbolicOperationRequest(symbolicOperation);

        System.out.println("[DPOR Strategy Message] : The result of the symbolic arithmetic operation is " +
                RuntimeEnvironment.solverResult);
        //updatePathSymbolicOperations(symbolicOperation, thread);
        solver.updatePathSymbolicOperations(symbolicOperation);
        SymExecutionEvent symExecutionEvent = RuntimeEnvironment.createSymExecutionEvent(thread,
                symbolicOperation.getFormula().toString(), solver.bothSatUnsat);
        RuntimeEnvironment.eventsRecord.add(symExecutionEvent);
        passEventToDPOR(symExecutionEvent);
        updateCurrentGraph(symExecutionEvent);
    }

    /**
     * @param thread
     * @param symbolicOperation
     */
    @Override
    public void nextSymAssumeRequest(Thread thread, SymbolicOperation symbolicOperation) {
        if (guidingActivate) {
            handleGuidingSymAssumeOperationRequest(thread, symbolicOperation);
        } else {
            handleNewSymAssumeOperationRequest(thread, symbolicOperation);
        }
    }

    private void handleNewSymAssumeOperationRequest(Thread thread, SymbolicOperation symbolicOperation) {
        solver.computeNewSymAssumeOperationRequest(symbolicOperation);
        System.out.println("[DPOR Strategy Message] : The result of the symbolic assume operation is " +
                RuntimeEnvironment.solverResult);

        if (RuntimeEnvironment.solverResult) {
            solver.updatePathSymbolicOperations(symbolicOperation);
        }

        SymAssumeEvent symAssumeEvent = RuntimeEnvironment.createSymAssumeEvent(thread, symbolicOperation);
        RuntimeEnvironment.eventsRecord.add(symAssumeEvent);
        passEventToDPOR(symAssumeEvent);
        updateCurrentGraph(symAssumeEvent);
    }

    private void handleGuidingSymAssumeOperationRequest(Thread thread, SymbolicOperation symbolicOperation) {
        SymAssumeEvent guidingSymAssumeEvent = (SymAssumeEvent) guidingEvent;
        RuntimeEnvironment.solverResult = guidingSymAssumeEvent.getResult();
        if (RuntimeEnvironment.solverResult) {
            solver.updatePathSymbolicOperations(symbolicOperation);
            solver.push(symbolicOperation);
        }
        SymAssumeEvent symAssumeEvent = RuntimeEnvironment.createSymAssumeEvent(thread, symbolicOperation);
        RuntimeEnvironment.eventsRecord.add(symAssumeEvent);
        addEventToCurrentGraph(symAssumeEvent);
    }

    /**
     * Handles the guiding symbolic operation request.
     * <p>
     * This method handles the guiding symbolic operation request. It sets the {@link RuntimeEnvironment#solverResult}
     * with the result of the {@link SymExecutionEvent#getResult()} of the {@link #guidingEvent}. Then, it updates the
     * path symbolic operations with the given symbolic operation and thread. It creates a new {@link SymExecutionEvent}
     * with the given thread, the formula of the symbolic operation, and the negatable value of the {@link #guidingEvent}.
     * Finally, it adds the created event to the {@link RuntimeEnvironment#eventsRecord} and passes the event to the
     * current graph.
     * </p>
     *
     * @param thread            is the thread that is going to execute the symbolic operation.
     * @param symbolicOperation is the symbolic operation that is going to be executed.
     */
    public void handleGuidingSymbolicOperationRequest(Thread thread, SymbolicOperation symbolicOperation) {
        SymExecutionEvent guidingSymExecutionEvent = (SymExecutionEvent) guidingEvent;
        RuntimeEnvironment.solverResult = guidingSymExecutionEvent.getResult();
        solver.updatePathSymbolicOperations(symbolicOperation);
        SymExecutionEvent symExecutionEvent = RuntimeEnvironment.createSymExecutionEvent(thread,
                symbolicOperation.getFormula().toString(), guidingSymExecutionEvent.isNegatable());
        if (symExecutionEvent.getResult()) {
            solver.push(symbolicOperation);
        } else {
            solver.push(solver.negateFormula(symbolicOperation.getFormula()));
        }
        //solver.push(symbolicOperation);
        RuntimeEnvironment.eventsRecord.add(symExecutionEvent);
        addEventToCurrentGraph(symExecutionEvent);
    }

    /**
     * Picks the next thread.
     * <p>
     * This method picks the next thread that is going to be executed. It returns the next guided thread if the
     * {@link #guidingActivate} is true. Otherwise, it returns the next random thread.
     * </p>
     *
     * @return the next thread that is going to be executed.
     */
    @Override
    public Thread pickNextThread() {
        if (guidingActivate) {
            return pickNextGuidedThread();
        } else {
            return pickNextReadyThread();
        }
    }

    /**
     * Indicates whether the execution is done or not.
     * <p>
     * This method indicates whether the execution is done or not. It returns true if the
     * {@link RuntimeEnvironment#mcGraphs} is empty. Otherwise, it returns false.
     * </p>
     *
     * @return true if the execution is done, otherwise false.
     */
    @Override
    public boolean done() {
        return RuntimeEnvironment.mcGraphs.isEmpty();
    }

    /**
     * Saves the execution graphs to a file.
     * <p>
     * This method saves the execution graphs to a file. It creates a new file with the given file name and writes the
     * execution graphs to the file.
     * </p>
     *
     * @param executionGraphs is the list of execution graphs that are going to be saved.
     * @param fileName        is the name of the file that is going to be created.
     * @throws IllegalArgumentException if the execution graphs or the file name is null.
     * @throws RuntimeException         if an error occurred while saving the graphs to the file.
     */
    public void saveGraphsToFile(List<ExecutionGraph> executionGraphs, String fileName) {
        if (executionGraphs == null || fileName == null) {
            throw new IllegalArgumentException("Arguments cannot be null");
        }

        try (FileOutputStream fileOut = new FileOutputStream(fileName);
             ObjectOutputStream out = new ObjectOutputStream(fileOut)) {
            out.writeObject(executionGraphs);
        } catch (IOException e) {
            throw new RuntimeException("Error occurred while saving graphs to file", e);
        }
    }

    /**
     * Loads the execution graphs from a file.
     * <p>
     * This method loads the execution graphs from a file. It reads the execution graphs from the file and returns the
     * loaded graphs.
     * </p>
     *
     * @param fileName is the name of the file that is going to be read.
     * @return the loaded execution graphs.
     * @throws IllegalArgumentException if the file name is null or empty.
     * @throws RuntimeException         if an error occurred while loading the graphs from the file.
     */
    @SuppressWarnings("unchecked")
    public List<ExecutionGraph> loadGraphsFromFile(String fileName) {
        if (fileName == null || fileName.isEmpty()) {
            throw new IllegalArgumentException("File name cannot be null or empty");
        }

        List<ExecutionGraph> loadedGraphs;

        try (FileInputStream fileIn = new FileInputStream(fileName);
             ObjectInputStream in = new ObjectInputStream(fileIn)) {
            Object object = in.readObject();
            if (object instanceof List) {
                loadedGraphs = (List<ExecutionGraph>) object;
            } else {
                throw new RuntimeException("The object is not an instance of List");
            }
        } catch (IOException i) {
            throw new RuntimeException("Error occurred while loading graphs from file", i);
        } catch (ClassNotFoundException c) {
            throw new RuntimeException("Class not found while loading graphs from file", c);
        }

        return loadedGraphs;
    }

    /**
     * Saves the buggy execution trace.
     * <p>
     * This method saves the buggy execution trace. It writes the {@link RuntimeEnvironment#eventsRecord} to the file.
     * </p>
     */
    @Override
    public void saveBuggyExecutionTrace() {
        try {
            FileOutputStream fileOut = new FileOutputStream(buggyTracePath + buggyTraceFile);
            ObjectOutputStream out = new ObjectOutputStream(fileOut);
            out.writeObject(RuntimeEnvironment.eventsRecord);
            out.close();
            fileOut.close();
            System.out.println("[DPOR Strategy Message] : Buggy execution trace is saved in " + buggyTracePath +
                    buggyTraceFile);
        } catch (IOException i) {
            i.printStackTrace();
        }
    }

    /**
     * Saves the execution state.
     * <p>
     * This method saves the execution state. It saves the {@link #mcGraphs} to the file and loads the saved graphs
     * to the {@link RuntimeEnvironment#mcGraphs} list. It also sets the {@link RuntimeEnvironment#numOfGraphs}
     * with the number of graphs that are available in the {@link DPOR#getGraphCounter()}.
     * </p>
     */
    @Override
    public void saveExecutionState() {
        if (!mcGraphs.isEmpty()) {
            RuntimeEnvironment.mcGraphs.addAllGraphs(mcGraphs);
        }
        RuntimeEnvironment.numOfGraphs = dpor.getGraphCounter();
    }

    /**
     * Handles the empty guiding events.
     * <p>
     * This method handles the empty guiding events. It prints a message that the guiding events is empty and finds the
     * new COs, STs, JTs, MCs, and TCs based on the current graph. Then, it sets the {@link #guidingActivate} to false.
     * </p>
     */
    abstract void handleEmptyGuidingEvents();

    /**
     * Makes a new copy of the COs.
     * <p>
     * This method makes a new copy of the current graph's COs. It iterates over the {@link ExecutionGraph#getCOs()} of
     * the {@link #guidingExecutionGraph} and finds the new COs based on the current graph. It returns the new COs.
     * </p>
     *
     * @return the new COs based on the current graph.
     */
    protected List<CO> findNewCOs() {
        List<CO> newCOs = new ArrayList<>();
        for (CO co : guidingExecutionGraph.getCOs()) {
            ReadsFrom firstWrite;
            WriteEvent secondWrite;

            if (co.getFirstWrite() instanceof InitializationEvent) {
                firstWrite = (ReadsFrom) currentGraph.getGraphEvents().get(0);
            } else {
                firstWrite = findWriteEvent((WriteEvent) co.getFirstWrite());
            }
            secondWrite = findWriteEvent(co.getSecondWrite());

            if (firstWrite != null && secondWrite != null) {
                newCOs.add(new CO(firstWrite, secondWrite));
            }
        }
        return newCOs;
    }

    protected List<Event> findNewEventsOrder() {
        List<Event> newEventsOrder = new ArrayList<>();
        for (Event event : guidingExecutionGraph.getEventsOrder()) {
            if (event instanceof ThreadEvent) {
                ThreadEvent threadEvent = findThreadEventInCurrentGraph((ThreadEvent) event);
                if (threadEvent != null) {
                    newEventsOrder.add(threadEvent);
                }
            } else if (event instanceof InitializationEvent) {
                newEventsOrder.add(currentGraph.getGraphEvents().get(0));
            }
        }
        return newEventsOrder;
    }

    /**
     * Finds the write event based on the current graph.
     * <p>
     * This method finds the write event based on the current graph. It returns the write event that is available in the
     * {@link #currentGraph}.
     * </p>
     *
     * @param tempWrite is the write event that is going to be found.
     * @return the write event that is available in the current graph.
     */
    protected WriteEvent findWriteEvent(WriteEvent tempWrite) {
        return currentGraph.getGraphEvents().stream()
                .filter(event -> event instanceof WriteEvent)
                .map(event -> (WriteEvent) event)
                .filter(writeEvent -> writeEvent.getTid() == tempWrite.getTid() &&
                        writeEvent.getSerial() == tempWrite.getSerial())
                .findFirst()
                .orElse(null);
    }

    /**
     * Makes a new copy of the STs.
     * <p>
     * This method makes a new copy of the current graph's STs. It iterates over the {@link ExecutionGraph#getSTs()} of
     * the {@link #guidingExecutionGraph} and finds the new STs based on the current graph. It returns the new STs.
     * </p>
     *
     * @return the new STs based on the current graph.
     */
    protected Set<Pair<Event, Event>> findNewSTs() {
        Set<Pair<Event, Event>> newSTs = new HashSet<>();
        for (Pair<Event, Event> st : guidingExecutionGraph.getSTs()) {
            ThreadEvent firstThreadEvent = findThreadEventInCurrentGraph((ThreadEvent) st.component1());
            ThreadEvent secondThreadEvent = findThreadEventInCurrentGraph((ThreadEvent) st.component2());
            if (firstThreadEvent != null && secondThreadEvent != null) {
                newSTs.add(new Pair<>(firstThreadEvent, secondThreadEvent));
            }
        }
        return newSTs;
    }

    /**
     * Makes a new copy of the MCs.
     * <p>
     * This method makes a new copy of the current graph's MCs. It iterates over the {@link ExecutionGraph#getMCs()} of
     * the {@link #guidingExecutionGraph} and finds the new MCs based on the current graph. It returns the new MCs.
     * </p>
     *
     * @return the new MCs based on the current graph.
     */
    protected Set<Pair<Event, Event>> findNewMCs() {
        Set<Pair<Event, Event>> newMCs = new HashSet<>();
        for (Pair<Event, Event> mc : guidingExecutionGraph.getMCs()) {
            ThreadEvent firstThreadEvent = findThreadEventInCurrentGraph((ThreadEvent) mc.component1());
            ThreadEvent secondThreadEvent = findThreadEventInCurrentGraph((ThreadEvent) mc.component2());
            if (firstThreadEvent != null && secondThreadEvent != null) {
                newMCs.add(new Pair<>(firstThreadEvent, secondThreadEvent));
            }
        }
        return newMCs;
    }

    /**
     * Makes a new copy of the TCs.
     * <p>
     * This method makes a new copy of the current graph's TCs. It iterates over the {@link ExecutionGraph#getTCs()} of
     * the {@link #guidingExecutionGraph} and finds the new TCs based on the current graph. It returns the new TCs.
     * </p>
     *
     * @return the new TCs based on the current graph.
     */
    protected Set<Pair<Event, Event>> findNewTCs() {
        Set<Pair<Event, Event>> newTCs = new HashSet<>();
        for (Pair<Event, Event> tc : guidingExecutionGraph.getTCs()) {
            ThreadEvent firstThreadEvent = findThreadEventInCurrentGraph((ThreadEvent) tc.component1());
            ThreadEvent secondThreadEvent = findThreadEventInCurrentGraph((ThreadEvent) tc.component2());
            if (firstThreadEvent != null && secondThreadEvent != null) {
                newTCs.add(new Pair<>(firstThreadEvent, secondThreadEvent));
            }
        }
        return newTCs;
    }

    /**
     * Makes a new copy of the PCs.
     * <p>
     * This method makes a new copy of the current graph's PCs. It iterates over the {@link ExecutionGraph#getPCs()} of
     * the {@link #guidingExecutionGraph} and finds the new PCs based on the current graph. It returns the new PCs.
     * </p>
     *
     * @return the new PCs based on the current graph.
     */
    protected Set<Pair<Event, Event>> findNewPCs() {
        Set<Pair<Event, Event>> newPCs = new HashSet<>();
        for (Pair<Event, Event> pc : guidingExecutionGraph.getPCs()) {
            ThreadEvent firstThreadEvent = findThreadEventInCurrentGraph((ThreadEvent) pc.component1());
            ThreadEvent secondThreadEvent = findThreadEventInCurrentGraph((ThreadEvent) pc.component2());
            if (firstThreadEvent != null && secondThreadEvent != null) {
                newPCs.add(new Pair<>(firstThreadEvent, secondThreadEvent));
            }
        }
        return newPCs;
    }

    protected Set<Pair<Event, Event>> findNewRecvfrom() {
        Set<Pair<Event, Event>> newRecvfrom = new HashSet<>();
        for (Pair<Event, Event> recvfrom : guidingExecutionGraph.getRecvFrom()) {
            ThreadEvent firstThreadEvent = findThreadEventInCurrentGraph((ThreadEvent) recvfrom.component1());
            ThreadEvent secondThreadEvent = findThreadEventInCurrentGraph((ThreadEvent) recvfrom.component2());
            if (firstThreadEvent != null && secondThreadEvent != null) {
                newRecvfrom.add(new Pair<>(firstThreadEvent, secondThreadEvent));
            }
        }
        return newRecvfrom;
    }

    /**
     * Finds the thread event based on the current graph.
     * <p>
     * This method finds the thread event based on the current graph. It returns the thread event that is available in the
     * {@link #currentGraph}.
     * </p>
     *
     * @param tempThreadEvent is the thread event that is going to be found.
     * @return the thread event that is available in the current graph.
     */
    protected ThreadEvent findThreadEventInCurrentGraph(ThreadEvent tempThreadEvent) {
        return currentGraph.getGraphEvents().stream()
                .filter(event -> event instanceof ThreadEvent)
                .map(event -> (ThreadEvent) event)
                .filter(threadEvent -> threadEvent.getTid() == tempThreadEvent.getTid() &&
                        threadEvent.getSerial() == tempThreadEvent.getSerial() &&
                        threadEvent.getType() == tempThreadEvent.getType())
                .findFirst()
                .orElse(null);
    }

    /**
     * Makes a new copy of the JTs.
     * <p>
     * This method makes a new copy of the current graph's JTs. It iterates over the {@link ExecutionGraph#getJTs()} of
     * the {@link #guidingExecutionGraph} and finds the new JTs based on the current graph. It returns the new JTs.
     * </p>
     *
     * @return the new JTs based on the current graph.
     */
    protected Set<Pair<Event, Event>> findNewJTs() {
        Set<Pair<Event, Event>> newJTs = new HashSet<>();
        for (Pair<Event, Event> jt : guidingExecutionGraph.getJTs()) {
            ThreadEvent firstThreadEvent = findThreadEventInCurrentGraph((ThreadEvent) jt.component1());
            ThreadEvent secondThreadEvent = findThreadEventInCurrentGraph((ThreadEvent) jt.component2());
            if (firstThreadEvent != null && secondThreadEvent != null) {
                newJTs.add(new Pair<>(firstThreadEvent, secondThreadEvent));
            }
        }
        return newJTs;
    }

    /**
     * Finds the guiding thread from the start event.
     * <p>
     * This method finds the guiding thread from the start event. It returns the thread id of the start event that is
     * available in the {@link #guidingExecutionGraph}.
     * </p>
     *
     * @return the thread id of the start event.
     */
    protected int findGuidingThreadFromStartEvent() {
        return guidingExecutionGraph.getSTs().stream()
                .filter(pair -> pair.component2().equals(guidingEvent))
                .map(pair -> ((ThreadEvent) pair.component1()).getTid())
                .findFirst()
                .orElse(0);
    }

    abstract Thread pickNextGuidedThread();

    abstract boolean isValidGraph(ExecutionGraph graph, ThreadEvent threadEvent);
}