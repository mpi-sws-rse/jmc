package org.mpisws.checker.strategy;

import dpor.DPOR;
import dpor.Trust;
import executionGraph.ExecutionGraph;
import executionGraph.Node;
import org.mpisws.checker.SearchStrategy;
import org.mpisws.runtime.RuntimeEnvironment;
import org.mpisws.solver.SymbolicSolver;
import programStructure.*;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;

public abstract class DPORStrategy implements SearchStrategy {

    /**
     * @property {@link #mcGraphs} is used to store the execution graphs that are generated by the model checker.
     */
    protected List<ExecutionGraph> mcGraphs;

    /**
     * @property {@link #currentGraph} is used to store the current execution graph.
     */
    protected ExecutionGraph currentGraph;

    /**
     * @property {@link #guidingActivate} is used to indicate whether the {@link #guidingExecutionGraph} is available or
     * not.
     */
    protected boolean guidingActivate = false;

    /**
     * @property {@link #guidingExecutionGraph} is used to store the guiding execution graph.
     */
    protected ExecutionGraph guidingExecutionGraph;

    /**
     * @property {@link #guidingNode} is used to store the current node of the {@link #guidingExecutionGraph}.
     */
    protected Node guidingNode;

    /**
     * @property {@link #guidingThread} is used to store the current active thread of the {@link #guidingExecutionGraph}.
     */
    protected int guidingThread;

    /**
     * @property {@link #guidingEvents} is used to store the events that are available in the {@link #guidingExecutionGraph}.
     */
    protected List<Event> guidingEvents;

    /**
     * @property {@link #guidingEvent} is used to store the current event of the {@link #guidingExecutionGraph}.
     */
    protected Event guidingEvent;

    /**
     * @property {@link #buggyTracePath} is used to store the path of the buggy trace file.
     */
    protected String buggyTracePath;

    /**
     * @property {@link #buggyTraceFile} is used to store the name of the buggy trace file.
     */
    protected String buggyTraceFile;

    /**
     * @property {@link #executionGraphsPath} is used to store the path of the execution graphs directory.
     */
    protected String executionGraphsPath;

    /**
     * @property {@link #solver} is keeping the reference to {@link RuntimeEnvironment#solver}
     */
    protected SymbolicSolver solver;

    /**
     * @property {@link #isNegatable} is a boolean value to check if the symbolic arithmetic operation is negatable.
     */
    protected boolean isNegatable = false;

    /**
     * @property {@link #dpor} is used to store the dpor-based model checker object.
     */
    protected DPOR dpor;


    public DPORStrategy() {
        buggyTracePath = RuntimeEnvironment.buggyTracePath;
        buggyTraceFile = RuntimeEnvironment.buggyTraceFile;
        executionGraphsPath = RuntimeEnvironment.executionGraphsPath;
        solver = RuntimeEnvironment.solver;
        if (!Files.exists(Paths.get(executionGraphsPath))) {
            System.out.println("[DPOR Strategy Message] : Directory " + executionGraphsPath + " does not exist ");
            System.exit(0);
        }
        if (!Files.exists(Paths.get(buggyTracePath))) {
            System.out.println("[DPOR Strategy Message] : Directory " + buggyTracePath + " does not exist ");
            System.exit(0);
        }
        initMcGraphs();
        initCurrentGraph();
        initGuidingGraph();
    }

    /**
     * Initializes the model checker graphs list.
     * <p>
     * This method initializes the {@link RuntimeEnvironment#mcGraphs} list and {@link #mcGraphs} list.
     * </p>
     */
    private void initMcGraphs() {
        if (RuntimeEnvironment.mcGraphs == null) {
            RuntimeEnvironment.mcGraphs = new ArrayList<>();
        }
        mcGraphs = new ArrayList<>();
    }

    /**
     * Initializes the current execution graph.
     * <p>
     * This method initializes the {@link #currentGraph} with the {@link InitializationEvent}.
     * </p>
     */
    private void initCurrentGraph() {
        currentGraph = new ExecutionGraph();
        currentGraph.addRoot(new InitializationEvent());
    }

    /**
     * Initializes the guiding execution graph.
     * <p>
     * This method initializes the {@link #guidingExecutionGraph} if the {@link RuntimeEnvironment#mcGraphs} is not empty.
     * Otherwise, it initializes the {@link #dpor} object with the root event of the {@link #currentGraph}.
     * </p>
     */
    private void initGuidingGraph() {
        if (!RuntimeEnvironment.mcGraphs.isEmpty()) {
            loadGuidingGraph();
            System.out.println("[DPOR Message] : The guiding execution graph is loaded");
            System.out.println("[DPOR Message] : The guiding execution graph is : G_" + guidingExecutionGraph.getId());
            System.out.println("[DPOR Message] : The guiding ordered events are : ");
            int index = 1;
            for (Event event : guidingEvents) {
                System.out.println("[DPOR Message] : " + index + "-" + event);
                index++;
            }
        } else {
            //noGuidingGraph();
        }
    }

    /**
     * Loads the guiding execution graph.
     * <p>
     * This method loads the guiding execution graph from the first element of the {@link RuntimeEnvironment#mcGraphs}
     * list, sets the {@link #guidingActivate} to true, initializes the {@link #guidingNode} with the root of the
     * {@link #guidingExecutionGraph}, sets the {@link #guidingThread} to 0, and initializes the {@link #guidingEvents}.
     * </p>
     */
    private void loadGuidingGraph() {
        System.out.println("[DPOR Strategy Message] : The RuntimeEnvironment has a guiding execution graph");
        guidingActivate = true;
        guidingExecutionGraph = RuntimeEnvironment.mcGraphs.remove(0);
        guidingNode = guidingExecutionGraph.getRoot();
        guidingThread = 0;
        guidingEvents = new ArrayList<>();
        findGuidingEvents();
    }

    /**
     * Computes the ordered list of the guiding events based on the guiding execution graph.
     * <p>
     * The following method is used to compute the ordered list of the guiding events from the
     * {@link #guidingExecutionGraph}. Base on the {@link ExecutionGraph#getSc()} of the {@link #guidingExecutionGraph},
     * it finds the order of the events that if it picks the first event, the second event does not have any left hand
     * side in the {@link ExecutionGraph#getSc()} of the {@link #guidingExecutionGraph} except the first event.
     * <br>
     * Note that the {@link ExecutionGraph#getGraphEvents()} (G.E in the dpor paper) and
     * {@link ExecutionGraph#getEventsOrder()} (\geq_{G} in the dpor paper) of the {@link #guidingExecutionGraph} are
     * not reliable to find the guiding events. Since a forward revisit can violate the happens-before relation between
     * the events of these two list.
     * </p>
     */
    private void findGuidingEvents() {
        List<Event> freeEvents = new ArrayList<>();
        freeEvents.add(guidingNode.getValue());

        List<Event> remainingEvents = new ArrayList<>(guidingExecutionGraph.getGraphEvents());
        remainingEvents.remove(guidingNode.getValue()); // remove the initialization event
        guidingExecutionGraph.computeSc();
        while (!remainingEvents.isEmpty()) {
            remainingEvents.removeIf(event -> {
                boolean isEventFree = guidingExecutionGraph.getSc().stream()
                        .noneMatch(pair -> pair.getSecond().equals(event) && !freeEvents.contains(pair.getFirst()));
                if (isEventFree) {
                    freeEvents.add(event);
                }
                return isEventFree;
            });
        }

        guidingEvents.addAll(freeEvents);
        guidingEvents.remove(0);
    }

    /**
     * Adds the given event to the current graph.
     * <p>
     * This method adds the event to the current graph. It sets the {@link #currentGraph} with the given event.
     * </p>
     *
     * @param event is the event that is going to be added to the current graph.
     */
    protected void addEventToCurrentGraph(Event event) {
        currentGraph.addEvent(event);
    }

    /**
     * Passes the given event to the {@link #dpor} model checker.
     * <p>
     * This method passes the event to the dpor model checker. It sets the {@link DPOR#getAllGraphs()} ()} with an
     * empty list to make sure that the {@link #dpor} model checker does not have any previous graphs. Then, it calls
     * the {@link DPOR#visit(ExecutionGraph, List)} method to visit the current graph with the given event.
     * </p>
     *
     * @param event is the event that is going to be passed to the {@link #dpor} model checker.
     */
    protected void passEventToDPOR(Event event) {
        List<Event> tempEventList = new ArrayList<>();
        tempEventList.add(event);
        dpor.setAllGraphs(new ArrayList<>());
        dpor.visit(currentGraph, tempEventList);
    }

    /**
     * Passes the given events to the {@link #dpor} model checker.
     *
     * @param events is the list of events that are going to be passed to the {@link #dpor} model checker.
     */
    protected void passEventToDPOR(List<Event> events) {
        dpor.setAllGraphs(new ArrayList<>());
        dpor.visit(currentGraph, events);
    }


    /**
     * Updates the current graph.
     * <p>
     * This method updates the {@link #currentGraph}. It sets the {@link #currentGraph} with the new graphs that are
     * available in the {@link DPOR#getAllGraphs()}. If there is only one new graph, it sets the {@link #currentGraph}
     * with the new graph. If there are more than one new graphs, it finds the extending graph. Otherwise, it creates a
     * new graph and sets the {@link #currentGraph} with the new graph.
     * </p>
     *
     * @param threadEvent is the thread event that is going to be executed.
     */
    protected void updateCurrentGraph(ThreadEvent threadEvent) {
        List<ExecutionGraph> newGraphs = dpor.getAllGraphs();
        if (newGraphs.size() == 1) {
            System.out.println("[DPOR Strategy Message] : There is only one new graph");
            currentGraph = newGraphs.get(0);
        } else if (newGraphs.size() > 1) {
            if (threadEvent.getType() == EventType.SYM_EXECUTION) {
                SymExecutionEvent symExecutionEvent = (SymExecutionEvent) threadEvent;
                findExtendingGraphOverSymbolicEvent(newGraphs, symExecutionEvent);
            } else {
                findExtendingGraph(newGraphs, threadEvent);
            }
        } else {
            int numOfGraphs = dpor.getGraphCounter() + 1;
            dpor.setGraphCounter(numOfGraphs);
            currentGraph.visualizeGraph(numOfGraphs, executionGraphsPath);
            System.out.println("[DPOR Strategy Message] : There is no new graph from model checker");
            System.out.println("[DPOR Strategy Message] : visited full execution graph G_" + numOfGraphs);
        }
    }


    private void findExtendingGraphOverSymbolicEvent(List<ExecutionGraph> newGraphs, SymExecutionEvent symExecutionEvent) {
        for (ExecutionGraph graph : newGraphs) {
            ThreadEvent lastEvent = (ThreadEvent) graph.getGraphEvents().get(graph.getGraphEvents().size() - 1);
            SymExecutionEvent lastSymEvent = (SymExecutionEvent) lastEvent;
            if (lastSymEvent.getResult() == symExecutionEvent.getResult()) {
                currentGraph = graph;
                newGraphs.remove(graph);
                mcGraphs.addAll(newGraphs);
                System.out.println("[DPOR Strategy Message] : The chosen graph is : " + currentGraph.getId());
                break;
            }
        }
    }

    /**
     * Finds the extending graph of the current graph.
     * <p>
     * This method finds the extending graph of the current graph. It adds the new graphs to the {@link #mcGraphs} list.
     * Then, it iterates over the {@link ExecutionGraph#getSc()} of each new graph and checks whether the left hand side
     * of the pair is equal to the given thread event. If it is not equal, it sets the {@link #currentGraph} with the
     * new graph. Otherwise, it removes the new graph from the {@link #mcGraphs} list.
     * </p>
     *
     * @param newGraphs   is the list of new graphs that are going to be checked.
     * @param threadEvent is the thread event that is going to be checked.
     */
    private void findExtendingGraph(List<ExecutionGraph> newGraphs, ThreadEvent threadEvent) {

        newGraphs.stream()
                .filter(graph -> isValidGraph(graph, threadEvent))
                .findFirst()
                .ifPresent(graph -> {
                    currentGraph = graph;
                    newGraphs.remove(graph);
                });

        mcGraphs.addAll(newGraphs);

        System.out.println("[DPOR Strategy Message] : The chosen graph is : " + currentGraph.getId());
    }

    /**
     * Represents the required strategy for the next start event.
     * <p>
     * This method represents the required strategy for the next start event. It creates a {@link StartEvent} for the
     * corresponding starting a thread request of a thread. The created {@link StartEvent} is added to the
     * {@link #currentGraph} if the {@link #guidingActivate} is true. Otherwise, it passes the event to the {@link #dpor}
     * model checker.
     * </p>
     *
     * @param calleeThread is the thread that is going to be started.
     * @param callerThread is the thread that is going to call the start method of the calleeThread.
     */
    @Override
    public void nextStartEvent(Thread calleeThread, Thread callerThread) {
        StartEvent st = RuntimeEnvironment.createStartEvent(calleeThread, callerThread);
        RuntimeEnvironment.eventsRecord.add(st);
        if (guidingActivate) {
            addEventToCurrentGraph(st);
        } else {
            passEventToDPOR(st);
        }
    }

    /**
     * Represents the required strategy for the next join event.
     * <p>
     * This method represents the required strategy for the next join event. It creates a {@link JoinEvent} for the
     * corresponding joining a thread request of a thread and records it. The created {@link JoinEvent} is added to the
     * {@link #currentGraph} if the {@link #guidingActivate} is true. Otherwise, it passes the event to the {@link #dpor}
     * model checker.
     * </p>
     *
     * @param joinReq is the thread that is going to join another thread.
     * @param joinRes is the thread that is going to be joined by another thread.
     */
    @Override
    public void nextJoinEvent(Thread joinReq, Thread joinRes) {
        JoinEvent joinEvent = RuntimeEnvironment.createJoinEvent(joinReq, joinRes);
        RuntimeEnvironment.eventsRecord.add(joinEvent);
        if (guidingActivate) {
            addEventToCurrentGraph(joinEvent);
        } else {
            passEventToDPOR(joinEvent);
        }
    }

    /**
     * Represents the required strategy for the next join request.
     * <p>
     * This method represents the required strategy for the next join request. It calls the
     * {@link #nextJoinEvent(Thread, Thread)} if the {@link #guidingActivate} is true. Otherwise, it puts the join request
     * and join response in the {@link RuntimeEnvironment#joinRequest} map and picks the next random thread.
     * </p>
     *
     * @param joinReq is the thread that is going to join another thread.
     * @param joinRes is the thread that is going to be joined by another thread.
     * @return the next thread that is going to be executed.
     */
    @Override
    public Thread nextJoinRequest(Thread joinReq, Thread joinRes) {
        if (guidingActivate) {
            nextJoinEvent(joinReq, joinRes);
            return joinReq;
        } else {
            RuntimeEnvironment.joinRequest.put(joinReq, joinRes);
            return pickNextRandomThread();
        }
    }

    /**
     * Represents the required strategy for the next finish event.
     * <p>
     * This method represents the required strategy for the next finish event. It creates a {@link FinishEvent} for the
     * corresponding finishing execution request of a thread and records it. The created {@link FinishEvent} is added to the
     * {@link #currentGraph} if the {@link #guidingActivate} is true. Otherwise, it passes the event to the {@link #dpor}
     * model checker. The method also analyzes the suspended threads for joining the finished thread.
     * </p>
     *
     * @param thread is the thread that is going to be finished.
     */
    @Override
    public void nextFinishEvent(Thread thread) {
        FinishEvent finishEvent = RuntimeEnvironment.createFinishEvent(thread);
        RuntimeEnvironment.eventsRecord.add(finishEvent);
        if (guidingActivate) {
            addEventToCurrentGraph(finishEvent);
            analyzeSuspendedThreadsForJoin(thread);
        } else {
            passEventToDPOR(finishEvent);
            analyzeSuspendedThreadsForJoin(thread);
        }
    }

    /**
     * Represents the required strategy for the next finish request.
     * <p>
     * This method represents the required strategy for the next finish request. It calls the
     * {@link #nextFinishEvent(Thread)} and picks the next thread based on the guiding execution graph if the
     * {@link #guidingActivate} is true. Otherwise, it picks the next random thread.
     * </p>
     *
     * @param thread is the thread that is going to be finished.
     * @return the next thread that is going to be executed.
     */
    @Override
    public Thread nextFinishRequest(Thread thread) {
        nextFinishEvent(thread);
        if (guidingActivate) {
            return pickNextGuidedThread();
        } else {
            return pickNextRandomThread();
        }
    }

    /**
     * Represents the required strategy for the next failure event.
     * <p>
     * This method represents the required strategy for the next failure event. It creates a {@link FailureEvent} for
     * the corresponding failing execution request of a thread and records it. The created {@link FailureEvent} is added
     * to the {@link #currentGraph} if the {@link #guidingActivate} is true. Otherwise, it passes the event to the
     * {@link #dpor} model checker.
     *
     * </p>
     *
     * @param thread is the thread that is going to be failed.
     */
    @Override
    public void nextFailureEvent(Thread thread) {
        FailureEvent failureEvent = RuntimeEnvironment.createFailureEvent(thread);
        RuntimeEnvironment.eventsRecord.add(failureEvent);
        if (guidingActivate) {
            addEventToCurrentGraph(failureEvent);
        } else {
            passEventToDPOR(failureEvent);
        }
    }

    /**
     * Represents the required strategy for the next deadlock event.
     * <p>
     * This method represents the required strategy for the next deadlock event. It creates a {@link DeadlockEvent} for
     * the corresponding deadlock between the threads and records it. The created {@link DeadlockEvent} is added
     * to the {@link #currentGraph} if the {@link #guidingActivate} is true. Otherwise, it passes the event to the
     * </p>
     *
     * @param thread is the thread that is going to be finished.
     */
    @Override
    public void nextDeadlockEvent(Thread thread) {
        DeadlockEvent deadlockEvent = RuntimeEnvironment.createDeadlockEvent(thread);
        RuntimeEnvironment.eventsRecord.add(deadlockEvent);
        if (guidingActivate) {
            addEventToCurrentGraph(deadlockEvent);
        } else {
            passEventToDPOR(deadlockEvent);
        }
    }

    /**
     * Picks the next thread.
     * <p>
     * This method picks the next thread that is going to be executed. It returns the next guided thread if the
     * {@link #guidingActivate} is true. Otherwise, it returns the next random thread.
     * </p>
     *
     * @return the next thread that is going to be executed.
     */
    @Override
    public Thread pickNextThread() {
        if (guidingActivate) {
            return pickNextGuidedThread();
        } else {
            return pickNextRandomThread();
        }
    }

    /**
     * Indicates whether the execution is done or not.
     * <p>
     * This method indicates whether the execution is done or not. It returns true if the
     * {@link RuntimeEnvironment#mcGraphs} is empty. Otherwise, it returns false.
     * </p>
     *
     * @return true if the execution is done, otherwise false.
     */
    @Override
    public boolean done() {
        return RuntimeEnvironment.mcGraphs.isEmpty();
    }

    /**
     * Saves the execution graphs to a file.
     * <p>
     * This method saves the execution graphs to a file. It creates a new file with the given file name and writes the
     * execution graphs to the file.
     * </p>
     *
     * @param executionGraphs is the list of execution graphs that are going to be saved.
     * @param fileName        is the name of the file that is going to be created.
     * @throws IllegalArgumentException if the execution graphs or the file name is null.
     * @throws RuntimeException         if an error occurred while saving the graphs to the file.
     */
    public void saveGraphsToFile(List<ExecutionGraph> executionGraphs, String fileName) {
        if (executionGraphs == null || fileName == null) {
            throw new IllegalArgumentException("Arguments cannot be null");
        }

        try (FileOutputStream fileOut = new FileOutputStream(fileName);
             ObjectOutputStream out = new ObjectOutputStream(fileOut)) {
            out.writeObject(executionGraphs);
        } catch (IOException e) {
            throw new RuntimeException("Error occurred while saving graphs to file", e);
        }
    }

    /**
     * Loads the execution graphs from a file.
     * <p>
     * This method loads the execution graphs from a file. It reads the execution graphs from the file and returns the
     * loaded graphs.
     * </p>
     *
     * @param fileName is the name of the file that is going to be read.
     * @return the loaded execution graphs.
     * @throws IllegalArgumentException if the file name is null or empty.
     * @throws RuntimeException         if an error occurred while loading the graphs from the file.
     */
    @SuppressWarnings("unchecked")
    public List<ExecutionGraph> loadGraphsFromFile(String fileName) {
        if (fileName == null || fileName.isEmpty()) {
            throw new IllegalArgumentException("File name cannot be null or empty");
        }

        List<ExecutionGraph> loadedGraphs;

        try (FileInputStream fileIn = new FileInputStream(fileName);
             ObjectInputStream in = new ObjectInputStream(fileIn)) {
            Object object = in.readObject();
            if (object instanceof List) {
                loadedGraphs = (List<ExecutionGraph>) object;
            } else {
                throw new RuntimeException("The object is not an instance of List");
            }
        } catch (IOException i) {
            throw new RuntimeException("Error occurred while loading graphs from file", i);
        } catch (ClassNotFoundException c) {
            throw new RuntimeException("Class not found while loading graphs from file", c);
        }

        return loadedGraphs;
    }

    /**
     * Saves the buggy execution trace.
     * <p>
     * This method saves the buggy execution trace. It writes the {@link RuntimeEnvironment#eventsRecord} to the file.
     * </p>
     */
    @Override
    public void saveBuggyExecutionTrace() {
        try {
            FileOutputStream fileOut = new FileOutputStream(buggyTracePath + buggyTraceFile);
            ObjectOutputStream out = new ObjectOutputStream(fileOut);
            out.writeObject(RuntimeEnvironment.eventsRecord);
            out.close();
            fileOut.close();
            System.out.println("[Trust Strategy Message] : Buggy execution trace is saved in " + buggyTracePath +
                    buggyTraceFile);
        } catch (IOException i) {
            i.printStackTrace();
        }
    }

    /**
     * Saves the execution state.
     * <p>
     * This method saves the execution state. It saves the {@link #mcGraphs} to the file and loads the saved graphs
     * to the {@link RuntimeEnvironment#mcGraphs} list. It also sets the {@link RuntimeEnvironment#numOfGraphs}
     * with the number of graphs that are available in the {@link Trust#getGraphCounter()}.
     * </p>
     */
    @Override
    public void saveExecutionState() {
        if (!mcGraphs.isEmpty()) {
            RuntimeEnvironment.mcGraphs.addAll(mcGraphs);
        }
        RuntimeEnvironment.numOfGraphs = dpor.getGraphCounter();
    }

    abstract Thread pickNextGuidedThread();

    abstract boolean isValidGraph(ExecutionGraph graph, ThreadEvent threadEvent);
}