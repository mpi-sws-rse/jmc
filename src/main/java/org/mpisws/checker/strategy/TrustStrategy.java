package org.mpisws.checker.strategy;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;

import dpor.Trust;
import executionGraph.CO;
import executionGraph.ExecutionGraph;
import executionGraph.Node;
import kotlin.Pair;
import org.mpisws.checker.SearchStrategy;
import org.mpisws.runtime.RuntimeEnvironment;
import org.mpisws.solver.SymbolicSolver;
import org.mpisws.symbolic.SymbolicOperation;
import programStructure.*;

/**
 * The TrustStrategy class implements the {@link SearchStrategy} interface and is responsible for managing the execution
 * order of events in a multithreaded program using the {@link Trust} model checker. It maintains a record of execution
 * graphs and a trust object for the trust model checker. The class provides functionality to handle various types of
 * events including start, join, read, write, finish, symbolic arithmetic events. The class uses the
 * {@link RuntimeEnvironment} API to create and record events. The TrustStrategy class is designed to control the flow
 * of a program's execution by using trust model checker. When it faces a new event, it passes the event to the trust
 * model checker and updates the current graph based on the model checker's response. Based on the response, it picks
 * the next thread to execute. The class also provides functionality to save the execution graphs to a file.
 */
public class TrustStrategy implements SearchStrategy {

    /**
     * @property {@link #trust} is used to store the trust object that is used to call the model checker.
     */
    public Trust trust;

    /**
     * @property {@link #mcGraphs} is used to store the execution graphs that are generated by the model checker.
     */
    public List<ExecutionGraph> mcGraphs;

    /**
     * @property {@link #currentGraph} is used to store the current execution graph.
     */
    public ExecutionGraph currentGraph;

    /**
     * @property {@link #guidingActivate} is used to indicate whether the {@link #guidingExecutionGraph} is available or
     * not.
     */
    private boolean guidingActivate = false;

    /**
     * @property {@link #guidingExecutionGraph} is used to store the guiding execution graph.
     */
    private ExecutionGraph guidingExecutionGraph;

    /**
     * @property {@link #guidingNode} is used to store the current node of the {@link #guidingExecutionGraph}.
     */
    private Node guidingNode;

    /**
     * @property {@link #guidingThread} is used to store the current active thread of the {@link #guidingExecutionGraph}.
     */
    private int guidingThread;

    /**
     * @property {@link #guidingEvents} is used to store the events that are available in the {@link #guidingExecutionGraph}.
     */
    private List<Event> guidingEvents;

    /**
     * @property {@link #guidingEvent} is used to store the current event of the {@link #guidingExecutionGraph}.
     */
    private Event guidingEvent;

    /**
     * @property {@link #buggyTracePath} is used to store the path of the buggy trace file.
     */
    private final String buggyTracePath;

    /**
     * @property {@link #buggyTraceFile} is used to store the name of the buggy trace file.
     */
    private final String buggyTraceFile;

    /**
     * @property {@link #executionGraphsPath} is used to store the path of the execution graphs directory.
     */
    private final String executionGraphsPath;

    /**
     * @property {@link #solver} is keeping the reference to {@link RuntimeEnvironment#solver}
     */
    private final SymbolicSolver solver;

    /**
     * @property {@link #isNegatable} is a boolean value to check if the symbolic arithmetic operation is negatable.
     */
    private boolean isNegatable = false;

    /**
     * The following constructor initializes the model checker graphs list, the current execution graph, and trust object,
     * the guiding execution graph if it is available. Moreover, it initializes the buggy trace path, the buggy trace file,
     * the execution graphs path, and the solver.
     */
    public TrustStrategy() {
        buggyTracePath = RuntimeEnvironment.buggyTracePath;
        buggyTraceFile = RuntimeEnvironment.buggyTraceFile;
        executionGraphsPath = RuntimeEnvironment.executionGraphsPath;
        solver = RuntimeEnvironment.solver;
        if (!Files.exists(Paths.get(executionGraphsPath))) {
            System.out.println("[Trust Strategy Message] : Directory " + executionGraphsPath + " does not exist ");
            System.exit(0);
        }
        if (!Files.exists(Paths.get(buggyTracePath))) {
            System.out.println("[Trust Strategy Message] : Directory " + buggyTracePath + " does not exist ");
            System.exit(0);
        }
        initMcGraphs();
        initCurrentGraph();
        initTrust();
        initGuidingGraph();
    }

    /**
     * Initializes the model checker graphs list.
     * <p>
     * This method initializes the {@link RuntimeEnvironment#mcGraphs} list and {@link #mcGraphs} list.
     * </p>
     */
    private void initMcGraphs() {
        if (RuntimeEnvironment.mcGraphs == null) {
            RuntimeEnvironment.mcGraphs = new ArrayList<>();
        }
        mcGraphs = new ArrayList<>();
    }

    /**
     * Initializes the current execution graph.
     * <p>
     * This method initializes the {@link #currentGraph} with the {@link InitializationEvent}.
     * </p>
     */
    private void initCurrentGraph() {
        currentGraph = new ExecutionGraph();
        currentGraph.addRoot(new InitializationEvent());
    }

    /**
     * Initializes the trust object.
     * <p>
     * This method initializes the {@link #trust} object. It sets the {@link Trust#getGraphCounter()} with the number of
     * graphs that are available in the {@link RuntimeEnvironment#mcGraphs}.
     * </p>
     */
    private void initTrust() {
        trust = new Trust(executionGraphsPath);
        trust.setGraphCounter(RuntimeEnvironment.numOfGraphs);
    }

    /**
     * Initializes the guiding execution graph.
     * <p>
     * This method initializes the {@link #guidingExecutionGraph} if the {@link RuntimeEnvironment#mcGraphs} is not empty.
     * Otherwise, it initializes the {@link #trust} object with the root event of the {@link #currentGraph}.
     * </p>
     */
    private void initGuidingGraph() {
        if (!RuntimeEnvironment.mcGraphs.isEmpty()) {
            loadGuidingGraph();
            System.out.println("[Trust Message] : The guiding execution graph is loaded");
            System.out.println("[Trust Message] : The guiding execution graph is : G_" + guidingExecutionGraph.getId());
            System.out.println("[Trust Message] : The guiding ordered events are : ");
            int index = 1;
            for (Event event : guidingEvents) {
                System.out.println("[Trust Message] : " + index + "-" + event);
                index++;
            }
        } else {
            noGuidingGraph();
        }
    }

    /**
     * Loads the guiding execution graph.
     * <p>
     * This method loads the guiding execution graph from the first element of the {@link RuntimeEnvironment#mcGraphs}
     * list, sets the {@link #guidingActivate} to true, initializes the {@link #guidingNode} with the root of the
     * {@link #guidingExecutionGraph}, sets the {@link #guidingThread} to 0, and initializes the {@link #guidingEvents}.
     * </p>
     */
    private void loadGuidingGraph() {
        System.out.println("[Trust Strategy Message] : The RuntimeEnvironment has a guiding execution graph");
        guidingActivate = true;
        guidingExecutionGraph = RuntimeEnvironment.mcGraphs.remove(0);
        guidingNode = guidingExecutionGraph.getRoot();
        guidingThread = 0;
        guidingEvents = new ArrayList<>();
        findGuidingEvents();
    }

    /**
     * Initializes the trust object with the root event of the current graph.
     * <p>
     * This method adds the root event of the {@link #currentGraph} to the {@link Trust#getAllEvents()}.
     * </p>
     */
    private void noGuidingGraph() {
        System.out.println("[Trust Strategy Message] : The guiding execution graph is empty");
        Optional<Event> event = Optional.of(Objects.requireNonNull(currentGraph.getRoot()).getValue());
        event.ifPresent(value -> trust.getAllEvents().add(value));
    }

    /**
     * Computes the ordered list of the guiding events based on the guiding execution graph.
     * <p>
     * The following method is used to compute the ordered list of the guiding events from the
     * {@link #guidingExecutionGraph}. Base on the {@link ExecutionGraph#getSc()} of the {@link #guidingExecutionGraph},
     * it finds the order of the events that if it picks the first event, the second event does not have any left hand
     * side in the {@link ExecutionGraph#getSc()} of the {@link #guidingExecutionGraph} except the first event.
     * <br>
     * Note that the {@link ExecutionGraph#getGraphEvents()} (G.E in the trust paper) and
     * {@link ExecutionGraph#getEventsOrder()} (\geq_{G} in the trust paper) of the {@link #guidingExecutionGraph} are
     * not reliable to find the guiding events. Since a forward revisit can violate the happens-before relation between
     * the events of these two list.
     * </p>
     */
    public void findGuidingEvents() {
        List<Event> freeEvents = new ArrayList<>();
        freeEvents.add(guidingNode.getValue());

        List<Event> remainingEvents = new ArrayList<>(guidingExecutionGraph.getGraphEvents());
        remainingEvents.remove(guidingNode.getValue()); // remove the initialization event
        guidingExecutionGraph.computeSc();
        while (!remainingEvents.isEmpty()) {
            remainingEvents.removeIf(event -> {
                boolean isEventFree = guidingExecutionGraph.getSc().stream()
                        .noneMatch(pair -> pair.getSecond().equals(event) && !freeEvents.contains(pair.getFirst()));
                if (isEventFree) {
                    freeEvents.add(event);
                }
                return isEventFree;
            });
        }

        guidingEvents.addAll(freeEvents);
        guidingEvents.remove(0);
    }

    /**
     * Represents the required strategy for the next start event.
     * <p>
     * This method represents the required strategy for the next start event. It creates a {@link StartEvent} for the
     * corresponding starting a thread request of a thread. The created {@link StartEvent} is added to the
     * {@link #currentGraph} if the {@link #guidingActivate} is true. Otherwise, it passes the event to the {@link #trust}
     * model checker.
     * </p>
     *
     * @param calleeThread is the thread that is going to be started.
     * @param callerThread is the thread that is going to call the start method of the calleeThread.
     */
    @Override
    public void nextStartEvent(Thread calleeThread, Thread callerThread) {
        StartEvent st = RuntimeEnvironment.createStartEvent(calleeThread, callerThread);
        RuntimeEnvironment.eventsRecord.add(st);
        if (guidingActivate) {
            addEventToCurrentGraph(st);
        } else {
            passEventToTrust(st);
        }
    }

    /**
     * Passes the given event to the {@link #trust} model checker.
     * <p>
     * This method passes the event to the trust model checker. It sets the {@link Trust#getAllGraphs()} ()} with an
     * empty list to make sure that the {@link #trust} model checker does not have any previous graphs. Then, it calls
     * the {@link Trust#visit(ExecutionGraph, List)} method to visit the current graph with the given event.
     * </p>
     *
     * @param event is the event that is going to be passed to the {@link #trust} model checker.
     */
    private void passEventToTrust(Event event) {
        List<Event> tempEventList = new ArrayList<>();
        tempEventList.add(event);
        trust.setAllGraphs(new ArrayList<>());
        trust.visit(currentGraph, tempEventList);
    }

    /**
     * Adds the given event to the current graph.
     * <p>
     * This method adds the event to the current graph. It sets the {@link #currentGraph} with the given event.
     * </p>
     *
     * @param event is the event that is going to be added to the current graph.
     */
    private void addEventToCurrentGraph(Event event) {
        currentGraph.addEvent(event);
    }

    /**
     * Represents the required strategy for the next enter monitor event.
     * <p>
     * This method represents the required strategy for the next enter monitor event. It creates a {@link EnterMonitorEvent}
     * for the corresponding entering a monitor request of a thread. First, it adds the created {@link EnterMonitorEvent}
     * to the {@link RuntimeEnvironment#eventsRecord}. Then, it adds the event to the {@link #currentGraph} if the
     * {@link #guidingActivate} is true. Otherwise, it passes the event to the {@link #trust} model checker and updates
     * the current graph.
     * </p>
     *
     * @param thread  is the thread that is going to enter the monitor.
     * @param monitor is the monitor that is going to be entered by the thread.
     */
    @Override
    public void nextEnterMonitorEvent(Thread thread, Object monitor) {
        EnterMonitorEvent enterMonitorEvent = RuntimeEnvironment.createEnterMonitorEvent(thread, monitor);
        RuntimeEnvironment.eventsRecord.add(enterMonitorEvent);
        if (guidingActivate) {
            addEventToCurrentGraph(enterMonitorEvent);
        } else {
            passEventToTrust(enterMonitorEvent);
            updateCurrentGraph(enterMonitorEvent);
        }
    }

    /**
     * Represents the required strategy for the next exit monitor event.
     * <p>
     * This method represents the required strategy for the next exit monitor event. It creates a {@link ExitMonitorEvent}
     * for the corresponding exiting a monitor request of a thread and records it. The created {@link ExitMonitorEvent}
     * is added to the {@link #currentGraph} if the {@link #guidingActivate} is true. Otherwise, it passes the event to
     * the {@link #trust} model checker and updates the current graph. The method also analyzes the suspended threads for
     * the monitor.
     * </p>
     *
     * @param thread  is the thread that is going to exit the monitor.
     * @param monitor is the monitor that is going to be exited by the thread.
     */
    @Override
    public void nextExitMonitorEvent(Thread thread, Object monitor) {
        ExitMonitorEvent exitMonitorEvent = RuntimeEnvironment.createExitMonitorEvent(thread, monitor);
        RuntimeEnvironment.eventsRecord.add(exitMonitorEvent);
        if (guidingActivate) {
            addEventToCurrentGraph(exitMonitorEvent);
            analyzeSuspendedThreadsForMonitor(monitor, thread);
        } else {
            passEventToTrust(exitMonitorEvent);
            updateCurrentGraph(exitMonitorEvent);
            analyzeSuspendedThreadsForMonitor(monitor, thread);
        }
    }

    /**
     * Represents the required strategy for the next join event.
     * <p>
     * This method represents the required strategy for the next join event. It creates a {@link JoinEvent} for the
     * corresponding joining a thread request of a thread and records it. The created {@link JoinEvent} is added to the
     * {@link #currentGraph} if the {@link #guidingActivate} is true. Otherwise, it passes the event to the {@link #trust}
     * model checker.
     * </p>
     *
     * @param joinReq is the thread that is going to join another thread.
     * @param joinRes is the thread that is going to be joined by another thread.
     */
    @Override
    public void nextJoinEvent(Thread joinReq, Thread joinRes) {
        JoinEvent joinEvent = RuntimeEnvironment.createJoinEvent(joinReq, joinRes);
        RuntimeEnvironment.eventsRecord.add(joinEvent);
        if (guidingActivate) {
            addEventToCurrentGraph(joinEvent);
        } else {
            passEventToTrust(joinEvent);
        }
    }

    @Override
    public void nextParkRequest(Thread thread) {
        ParkEvent parkRequestEvent = RuntimeEnvironment.createParkEvent(thread);
        RuntimeEnvironment.eventsRecord.add(parkRequestEvent);
        if (guidingActivate) {
            addEventToCurrentGraph(parkRequestEvent);
        } else {
            long tid = RuntimeEnvironment.threadIdMap.get(thread.getId());
            if (RuntimeEnvironment.threadParkingPermit.get(tid)) {
                RuntimeEnvironment.threadParkingPermit.put(tid, false);
                passEventToTrust(parkRequestEvent);
            } else {
                parkThread(thread);
                passEventToTrust(parkRequestEvent);
            }
        }
    }

    @Override
    public void nextUnparkRequest(Thread unparkerThread, Thread unparkeeThread) {
        UnparkingEvent unparkRequestEvent = RuntimeEnvironment.createUnparkingEvent(unparkerThread, unparkeeThread);
        RuntimeEnvironment.eventsRecord.add(unparkRequestEvent);
        if (guidingActivate) {
            addEventToCurrentGraph(unparkRequestEvent);
        } else {
            passEventToTrust(unparkRequestEvent);
        }
    }

    /**
     * Represents the required strategy for the next join request.
     * <p>
     * This method represents the required strategy for the next join request. It calls the
     * {@link #nextJoinEvent(Thread, Thread)} if the {@link #guidingActivate} is true. Otherwise, it puts the join request
     * and join response in the {@link RuntimeEnvironment#joinRequest} map and picks the next random thread.
     * </p>
     *
     * @param joinReq is the thread that is going to join another thread.
     * @param joinRes is the thread that is going to be joined by another thread.
     * @return the next thread that is going to be executed.
     */
    @Override
    public Thread nextJoinRequest(Thread joinReq, Thread joinRes) {
        if (guidingActivate) {
            nextJoinEvent(joinReq, joinRes);
            return joinReq;
        } else {
            RuntimeEnvironment.joinRequest.put(joinReq, joinRes);
            return pickNextRandomThread();
        }
    }

    /**
     * Represents the required strategy for the next read event.
     * <p>
     * This method represents the required strategy for the next read event. It passes the read event to the {@link #trust}
     * model checker if the {@link #guidingActivate} is false and updates the current graph. Otherwise, it adds the read
     * event to the current graph coupled with the reads-from edge.
     * </p>
     *
     * @param readEvent is the read event that is going to be executed.
     */
    @Override
    public void nextReadEvent(ReadEvent readEvent) {
        RuntimeEnvironment.eventsRecord.add(readEvent);
        if (guidingActivate) {
            addEventToCurrentGraph(readEvent);
            addRfEdgeToCurrentGraph(readEvent);
        } else {
            passEventToTrust(readEvent);
            updateCurrentGraph(readEvent);
        }
    }

    /**
     * Adds the reads-from edge to the current graph.
     * <p>
     * This method adds the reads-from edge to the {@link #currentGraph}. It sets the reads-from edge of the read event
     * to the {@link #currentGraph}.
     * </p>
     *
     * @param readEvent is the read event that is going to be executed.
     */
    private void addRfEdgeToCurrentGraph(ReadEvent readEvent) {
        Optional<ReadsFrom> readsFrom = Optional.ofNullable(findRfEdge((ReadEvent) guidingEvent));
        readsFrom.ifPresent(readEvent::setRf);
    }

    /**
     * Finds the reads-from edge of the read event.
     * <p>
     * This method finds the reads-from edge of the read event. It returns the reads-from corresponding event to the
     * read event.
     * </p>
     *
     * @param readEvent is the read event that is going to be executed.
     * @return the corresponding reads-from event to the read event.
     */
    private ReadsFrom findRfEdge(ReadEvent readEvent) {
        ReadsFrom readsFrom;

        if (readEvent.getRf() instanceof InitializationEvent) {
            readsFrom = (ReadsFrom) currentGraph.getGraphEvents().get(0);
        } else {
            WriteEvent tempWrite = (WriteEvent) readEvent.getRf();

            readsFrom = currentGraph.getGraphEvents().stream()
                    .filter(event -> event instanceof WriteEvent)
                    .map(event -> (WriteEvent) event)
                    .filter(writeEvent -> writeEvent.getTid() == Objects.requireNonNull(tempWrite).getTid() &&
                            writeEvent.getSerial() == tempWrite.getSerial())
                    .findFirst()
                    .orElse(null);
        }
        return readsFrom;
    }

    /**
     * Updates the current graph.
     * <p>
     * This method updates the {@link #currentGraph}. It sets the {@link #currentGraph} with the new graphs that are
     * available in the {@link Trust#getAllGraphs()}. If there is only one new graph, it sets the {@link #currentGraph}
     * with the new graph. If there are more than one new graphs, it finds the extending graph. Otherwise, it creates a
     * new graph and sets the {@link #currentGraph} with the new graph.
     * </p>
     *
     * @param threadEvent is the thread event that is going to be executed.
     */
    private void updateCurrentGraph(ThreadEvent threadEvent) {
        List<ExecutionGraph> newGraphs = trust.getAllGraphs();
        if (newGraphs.size() == 1) {
            System.out.println("[Trust Strategy Message] : There is only one new graph");
            currentGraph = newGraphs.get(0);
        } else if (newGraphs.size() > 1) {
            findExtendingGraph(newGraphs, threadEvent);
        } else {
            int numOfGraphs = trust.getGraphCounter() + 1;
            trust.setGraphCounter(numOfGraphs);
            currentGraph.visualizeGraph(numOfGraphs, executionGraphsPath);
            System.out.println("[Trust Strategy Message] : There is no new graph from model checker");
            System.out.println("[Trust Strategy Message] : visited full execution graph G_" + numOfGraphs);
        }
    }

    /**
     * Finds the extending graph of the current graph.
     * <p>
     * This method finds the extending graph of the current graph. It adds the new graphs to the {@link #mcGraphs} list.
     * Then, it iterates over the {@link ExecutionGraph#getSc()} of each new graph and checks whether the left hand side
     * of the pair is equal to the given thread event. If it is not equal, it sets the {@link #currentGraph} with the
     * new graph. Otherwise, it removes the new graph from the {@link #mcGraphs} list.
     * </p>
     *
     * @param newGraphs   is the list of new graphs that are going to be checked.
     * @param threadEvent is the thread event that is going to be checked.
     */
    public void findExtendingGraph(List<ExecutionGraph> newGraphs, ThreadEvent threadEvent) {

        newGraphs.stream()
                .filter(graph -> isValidGraph(graph, threadEvent))
                .findFirst()
                .ifPresent(graph -> {
                    currentGraph = graph;
                    newGraphs.remove(graph);
                });

        mcGraphs.addAll(newGraphs);

        System.out.println("[Trust Strategy Message] : The chosen graph is : " + currentGraph.getId());
    }

    /**
     * Checks whether the graph is valid or not.
     * <p>
     * This method checks whether the graph is valid or not. It returns true if the {@link ExecutionGraph#getSc()} of the
     * graph does not contain the given thread event. Otherwise, it returns false.
     * </p>
     *
     * @param graph       is the graph that is going to be checked.
     * @param threadEvent is the thread event that is going to be checked.
     * @return true if the graph is valid, otherwise false.
     */
    private boolean isValidGraph(ExecutionGraph graph, ThreadEvent threadEvent) {
        return graph.getSc().stream()
                .noneMatch(pair -> pair.component1().getType() == threadEvent.getType() &&
                        ((ThreadEvent) pair.component1()).getTid() == threadEvent.getTid() &&
                        ((ThreadEvent) pair.component1()).getSerial() == threadEvent.getSerial());
    }

    /**
     * Represents the required strategy for the next write event.
     * <p>
     * This method represents the required strategy for the next write event. It passes the write event to the
     * {@link #trust} model checker if the {@link #guidingActivate} is false and updates the current graph. Otherwise,
     * it adds the write event to the current graph.
     * </p>
     *
     * @param writeEvent is the write event that is going to be executed.
     */
    @Override
    public void nextWriteEvent(WriteEvent writeEvent) {
        RuntimeEnvironment.eventsRecord.add(writeEvent);
        if (guidingActivate) {
            addEventToCurrentGraph(writeEvent);
        } else {
            passEventToTrust(writeEvent);
            updateCurrentGraph(writeEvent);
        }
    }

    /**
     * Represents the required strategy for the next finish event.
     * <p>
     * This method represents the required strategy for the next finish event. It creates a {@link FinishEvent} for the
     * corresponding finishing execution request of a thread and records it. The created {@link FinishEvent} is added to the
     * {@link #currentGraph} if the {@link #guidingActivate} is true. Otherwise, it passes the event to the {@link #trust}
     * model checker. The method also analyzes the suspended threads for joining the finished thread.
     * </p>
     *
     * @param thread is the thread that is going to be finished.
     */
    @Override
    public void nextFinishEvent(Thread thread) {
        FinishEvent finishEvent = RuntimeEnvironment.createFinishEvent(thread);
        RuntimeEnvironment.eventsRecord.add(finishEvent);
        if (guidingActivate) {
            addEventToCurrentGraph(finishEvent);
            analyzeSuspendedThreadsForJoin(thread);
        } else {
            passEventToTrust(finishEvent);
            analyzeSuspendedThreadsForJoin(thread);
        }
    }

    /**
     * Represents the required strategy for the next enter monitor request.
     * <p>
     * This method represents the required strategy for the next enter monitor request. It creates a
     * {@link MonitorRequestEvent} for the corresponding entering a monitor request of a thread and records it.
     * The created {@link MonitorRequestEvent} is added to the {@link #currentGraph} if the {@link #guidingActivate} is
     * true. Otherwise, it passes the event to the {@link #trust} model checker. The method also checks the deadlock
     * detection between the threads in using the monitors. If there is a deadlock, it sets the
     * {@link RuntimeEnvironment#deadlockHappened} to true and sets the {@link RuntimeEnvironment#executionFinished} to
     * true. Otherwise, it picks the next thread to execute.
     * </p>
     *
     * @param thread  is the thread that is going to enter the monitor.
     * @param monitor is the monitor that is going to be entered by the thread.
     * @return the next thread that is going to be executed.
     */
    @Override
    public Thread nextEnterMonitorRequest(Thread thread, Object monitor) {
        MonitorRequestEvent monitorRequestEvent = RuntimeEnvironment.createMonitorRequestEvent(thread, monitor);
        RuntimeEnvironment.eventsRecord.add(monitorRequestEvent);
        RuntimeEnvironment.monitorRequest.put(thread, monitor);
        if (guidingActivate) {
            addEventToCurrentGraph(monitorRequestEvent);
        } else {
            passEventToTrust(monitorRequestEvent);
        }
        if (monitorsDeadlockDetection()) {
            System.out.println(
                    "[Trust Strategy Message] : There is a deadlock between the threads in using " +
                            "the monitors"
            );
            RuntimeEnvironment.deadlockHappened = true;
            RuntimeEnvironment.executionFinished = true;
            return null;
        } else {
            System.out.println(
                    "[Trust Strategy Message] : There is no deadlock between the threads in using " +
                            "the monitors"
            );
            return pickNextThread();
        }
    }

    /**
     * Represents the required strategy for the next finish request.
     * <p>
     * This method represents the required strategy for the next finish request. It calls the
     * {@link #nextFinishEvent(Thread)} and picks the next thread based on the guiding execution graph if the
     * {@link #guidingActivate} is true. Otherwise, it picks the next random thread.
     * </p>
     *
     * @param thread is the thread that is going to be finished.
     * @return the next thread that is going to be executed.
     */
    @Override
    public Thread nextFinishRequest(Thread thread) {
        nextFinishEvent(thread);
        if (guidingActivate) {
            return pickNextGuidedThread();
        } else {
            return pickNextRandomThread();
        }
    }

    /**
     * Represents the required strategy for the next symbolic operation request.
     * <p>
     * This method represents the required strategy for the next symbolic operation request. It calls the
     * {@link #handleGuidingSymbolicOperationRequest(Thread, SymbolicOperation)} if the {@link #guidingActivate} is true.
     * Otherwise, it calls the {@link #handleNewSymbolicOperationRequest(Thread, SymbolicOperation)}.
     * </p>
     *
     * @param symbolicOperation is the symbolic operation that is going to be executed.
     */
    @Override
    public void nextSymbolicOperationRequest(Thread thread, SymbolicOperation symbolicOperation) {
        if (guidingActivate) {
            handleGuidingSymbolicOperationRequest(thread, symbolicOperation);
        } else {
            handleNewSymbolicOperationRequest(thread, symbolicOperation);
        }
    }

    /**
     * Handles the guiding symbolic operation request.
     * <p>
     * This method handles the guiding symbolic operation request. It sets the {@link RuntimeEnvironment#solverResult}
     * with the result of the {@link SymExecutionEvent#getResult()} of the {@link #guidingEvent}. Then, it updates the
     * path symbolic operations with the given symbolic operation and thread. It creates a new {@link SymExecutionEvent}
     * with the given thread, the formula of the symbolic operation, and the negatable value of the {@link #guidingEvent}.
     * Finally, it adds the created event to the {@link RuntimeEnvironment#eventsRecord} and passes the event to the
     * current graph.
     * </p>
     *
     * @param thread            is the thread that is going to execute the symbolic operation.
     * @param symbolicOperation is the symbolic operation that is going to be executed.
     */
    public void handleGuidingSymbolicOperationRequest(Thread thread, SymbolicOperation symbolicOperation) {
        SymExecutionEvent guidingSymExecutionEvent = (SymExecutionEvent) guidingEvent;
        RuntimeEnvironment.solverResult = guidingSymExecutionEvent.getResult();
        updatePathSymbolicOperations(symbolicOperation, thread);
        SymExecutionEvent symExecutionEvent = RuntimeEnvironment.createSymExecutionEvent(thread,
                symbolicOperation.getFormula().toString(), guidingSymExecutionEvent.isNegatable());
        RuntimeEnvironment.eventsRecord.add(symExecutionEvent);
        addEventToCurrentGraph(symExecutionEvent);
    }

    /**
     * Handles the new symbolic operation request.
     * <p>
     * This method handles the new symbolic operation request. It finds the dependent formulas of the given symbolic
     * operation. If there is no dependent formula, it calls the {@link #handleFreeFormulas(SymbolicOperation)}
     * method. Otherwise, it calls the {@link #handleDependentFormulas(SymbolicOperation, List)} method. Then, it
     * updates the path symbolic operations with the given symbolic operation and thread. It creates a new
     * {@link SymExecutionEvent} with the given thread, the formula of the symbolic operation, and the negatable value.
     * Finally, it adds the created event to the {@link RuntimeEnvironment#eventsRecord} and passes the event to the trust.
     * </p>
     *
     * @param symbolicOperation is the symbolic operation that is going to be added to the path symbolic operations.
     * @param thread            is the thread that is going to execute the symbolic operation.
     */
    public void handleNewSymbolicOperationRequest(Thread thread, SymbolicOperation symbolicOperation) {
        List<SymbolicOperation> dependentOperations = findDependentFormulas(symbolicOperation);
        if (dependentOperations == null) {
            handleFreeFormulas(symbolicOperation);
            System.out.println("[Trust Strategy Message] : The result of the symbolic arithmetic operation is " +
                    RuntimeEnvironment.solverResult);
        } else {
            handleDependentFormulas(symbolicOperation, dependentOperations);
            System.out.println("[Trust Strategy Message] : The result of the symbolic arithmetic operation is " +
                    RuntimeEnvironment.solverResult);
        }
        updatePathSymbolicOperations(symbolicOperation, thread);
        SymExecutionEvent symExecutionEvent = RuntimeEnvironment.createSymExecutionEvent(thread,
                symbolicOperation.getFormula().toString(), isNegatable);
        RuntimeEnvironment.eventsRecord.add(symExecutionEvent);
        passEventToTrust(symExecutionEvent);
    }

    /**
     * Finds the dependent formulas of the given symbolic operation.
     * <p>
     * This method finds the dependent formulas of the given symbolic operation. It iterates over the path symbolic
     * operations and checks whether the given symbolic operation is dependent on another symbolic operation. If it is
     * dependent, it adds the dependent symbolic operation to the list of dependent formulas. Otherwise, it returns null.
     * </p>
     *
     * @param symbolicOperation is the symbolic operation that is going to be checked.
     * @return the list of dependent formulas of the given symbolic operation.
     */
    private List<SymbolicOperation> findDependentFormulas(SymbolicOperation symbolicOperation) {
        List<SymbolicOperation> dependencyOperations = new ArrayList<>();
        List<SymbolicOperation> symbolicOperations = RuntimeEnvironment.pathSymbolicOperations;
        for (SymbolicOperation symOp : symbolicOperations) {
            if (symOp.isFormulaDependent(symbolicOperation)) {
                System.out.println("[Trust Strategy Message] : The symbolic arithmetic operation is dependent on " +
                        "another symbolic arithmetic operation");
                System.out.println("[Trust Strategy Message] : The dependent symbolic arithmetic operations are : " +
                        symOp.getFormula().toString() + " and " + symbolicOperation.getFormula().toString());
                dependencyOperations.add(symOp);
            }
        }
        if (dependencyOperations.isEmpty()) {
            return null;
        } else {
            return dependencyOperations;
        }
    }

    /**
     * Finds the dependent formulas of the given symbolic operation based on the thread.
     * <p>
     * This method finds the dependent formulas of the given symbolic operation based on the thread. It iterates over the
     * symbolic operations of the thread and checks whether the given symbolic operation is dependent on another symbolic
     * operation. If it is dependent, it adds the dependent symbolic operation to the list of dependent formulas. Otherwise,
     * it returns null.
     * </p>
     *
     * @param thread            is the thread that is going to be checked.
     * @param symbolicOperation is the symbolic operation that is going to be checked.
     * @return the list of dependent formulas of the given symbolic operation.
     */
    private List<SymbolicOperation> findDependentThreadFormulas(Thread thread, SymbolicOperation symbolicOperation) {
        List<SymbolicOperation> dependencyOperations = new ArrayList<>();
        List<SymbolicOperation> symbolicOperations = RuntimeEnvironment.threadSymbolicOperation.get(
                RuntimeEnvironment.threadIdMap.get(thread.getId())
        );
        for (SymbolicOperation symOp : symbolicOperations) {
            if (symOp.isFormulaDependent(symbolicOperation)) {
                dependencyOperations.add(symOp);
            }
        }
        if (dependencyOperations.isEmpty()) {
            return null;
        } else {
            return dependencyOperations;
        }

    }

    /**
     * Handles the free formulas.
     * <p>
     * This method handles the free formulas. It calls the {@link #solveSat(SymbolicOperation)} and
     * {@link #solveUnsat(SymbolicOperation)} methods to solve the symbolic operation. Then, it calls the
     * {@link #pickSatOrUnsat(boolean, boolean)} method to pick the result of the symbolic operation. Finally, it sets
     * the {@link RuntimeEnvironment#solverResult} with the result of the symbolic operation.
     * </p>
     *
     * @param symbolicOperation is the symbolic operation that is going to be solved.
     */
    private void handleFreeFormulas(SymbolicOperation symbolicOperation) {
        System.out.println("[Random Strategy Message] : The symbolic arithmetic operation is free from dependencies");
        boolean sat = solveSat(symbolicOperation);
        boolean unSat = solveUnsat(symbolicOperation);
        isNegatable = sat && unSat;
        RuntimeEnvironment.solverResult = pickSatOrUnsat(sat, unSat);
    }

    /**
     * Handles the dependent formulas.
     * <p>
     * This method handles the dependent formulas. First, it creates a dependency operation from the list of dependent
     * formulas. Then, it calls the {@link #solveDependentSat(SymbolicOperation, SymbolicOperation)}
     * and {@link #solveDependentUnsat(SymbolicOperation, SymbolicOperation)} methods to solve the symbolic operation. Then,
     * it calls the {@link #pickSatOrUnsat(boolean, boolean)} method to pick the result of the symbolic operation. Finally,
     * it sets the {@link RuntimeEnvironment#solverResult} with the result of the symbolic operation.
     * </p>
     *
     * @param symbolicOperation   is the symbolic operation that is going to be solved.
     * @param dependentOperations is the list of dependent formulas of the symbolic operation.
     */
    private void handleDependentFormulas(SymbolicOperation symbolicOperation, List<SymbolicOperation> dependentOperations) {
        System.out.println("[Random Strategy Message] : The symbolic arithmetic operation has dependencies");
        SymbolicOperation dependency = solver.makeDependencyOperation(dependentOperations);
        boolean sat = solveDependentSat(symbolicOperation, dependency);
        boolean unSat = solveDependentUnsat(symbolicOperation, dependency);
        isNegatable = sat && unSat;
        RuntimeEnvironment.solverResult = pickSatOrUnsat(sat, unSat);
    }

    /**
     * Solves the symbolic operation.
     *
     * @param symbolicOperation is the symbolic operation that is going to be solved.
     * @return true if the symbolic operation is satisfiable, otherwise false.
     */
    private boolean solveSat(SymbolicOperation symbolicOperation) {
        return solver.solveSymbolicFormula(symbolicOperation);
    }

    /**
     * Solves the dependent symbolic operation.
     *
     * @param symbolicOperation is the symbolic operation that is going to be solved.
     * @param dependency        is the dependent symbolic operation.
     * @return true if the symbolic operation is satisfiable, otherwise false.
     */
    private boolean solveDependentSat(SymbolicOperation symbolicOperation, SymbolicOperation dependency) {
        return solver.solveDependentSymbolicFormulas(symbolicOperation, dependency);
    }

    /**
     * Solves the unsatisfiable symbolic operation.
     *
     * @param symbolicOperation is the symbolic operation that is going to be solved.
     * @return true if the symbolic operation is unsatisfiable, otherwise false.
     */
    private boolean solveUnsat(SymbolicOperation symbolicOperation) {
        return solver.disSolveSymbolicFormula(symbolicOperation);
    }

    /**
     * Solves the dependent unsatisfiable symbolic operation.
     *
     * @param symbolicOperation is the symbolic operation that is going to be solved.
     * @param dependency        is the dependent symbolic operation.
     * @return true if the symbolic operation is unsatisfiable, otherwise false.
     */
    private boolean solveDependentUnsat(SymbolicOperation symbolicOperation, SymbolicOperation dependency) {
        return solver.disSolveDependentSymbolicFormulas(symbolicOperation, dependency);
    }

    /**
     * Picks the result of the symbolic operation.
     *
     * @param sat   is the satisfiability of the symbolic operation.
     * @param unSat is the unsatisfiability of the symbolic operation.
     * @return true if the symbolic operation is satisfiable, otherwise false.
     */
    private boolean pickSatOrUnsat(boolean sat, boolean unSat) {
        if (sat && unSat) {
            System.out.println("[Random Strategy Message] : Both SAT and UNSAT are possible for the symbolic " +
                    "arithmetic operation");
            return new Random().nextBoolean();
        } else if (sat) {
            System.out.println("[Random Strategy Message] : Only SAT is possible for the symbolic arithmetic " +
                    "operation");
            return true;
        } else if (unSat) {
            System.out.println("[Random Strategy Message] : Only UNSAT is possible for the symbolic arithmetic " +
                    "operation");
            return false;
        } else {
            System.out.println("[Random Strategy Message] : No solution is found for the symbolic arithmetic " +
                    "operation");
            System.exit(0);
            return false;
        }
    }

    /**
     * Represents the required strategy for the next failure event.
     * <p>
     * This method represents the required strategy for the next failure event. It creates a {@link FailureEvent} for
     * the corresponding failing execution request of a thread and records it. The created {@link FailureEvent} is added
     * to the {@link #currentGraph} if the {@link #guidingActivate} is true. Otherwise, it passes the event to the
     * {@link #trust} model checker.
     *
     * </p>
     *
     * @param thread is the thread that is going to be failed.
     */
    @Override
    public void nextFailureEvent(Thread thread) {
        FailureEvent failureEvent = RuntimeEnvironment.createFailureEvent(thread);
        RuntimeEnvironment.eventsRecord.add(failureEvent);
        if (guidingActivate) {
            addEventToCurrentGraph(failureEvent);
        } else {
            passEventToTrust(failureEvent);
        }
    }

    /**
     * Represents the required strategy for the next deadlock event.
     * <p>
     * This method represents the required strategy for the next deadlock event. It creates a {@link DeadlockEvent} for
     * the corresponding deadlock between the threads and records it. The created {@link DeadlockEvent} is added
     * to the {@link #currentGraph} if the {@link #guidingActivate} is true. Otherwise, it passes the event to the
     * </p>
     *
     * @param thread is the thread that is going to be finished.
     */
    @Override
    public void nextDeadlockEvent(Thread thread) {
        DeadlockEvent deadlockEvent = RuntimeEnvironment.createDeadlockEvent(thread);
        RuntimeEnvironment.eventsRecord.add(deadlockEvent);
        if (guidingActivate) {
            addEventToCurrentGraph(deadlockEvent);
        } else {
            passEventToTrust(deadlockEvent);
        }
    }

    /**
     * Represents the required strategy for the next suspend event.
     * <p>
     * This method represents the required strategy for the next suspend event. It creates a {@link SuspendEvent} for
     * the corresponding suspending execution request of a thread and records it. The created {@link SuspendEvent} is
     * added to the {@link #currentGraph}.
     * </p>
     *
     * @param thread  is the thread that is going to be suspended.
     * @param monitor is the monitor that the thread is going to be suspended for it.
     */
    private void nextSuspendEvent(Thread thread, Object monitor) {
        SuspendEvent suspendEvent = RuntimeEnvironment.createSuspendEvent(thread, monitor);
        addEventToCurrentGraph(suspendEvent);
    }

    /**
     * Picks the next guided thread.
     * <p>
     * This method picks the next guided thread. It checks whether the {@link #guidingEvents} is empty or not. If it is
     * empty, it calls the {@link #handleEmptyGuidingEvents()} method and picks the next random thread. Otherwise, it
     * picks the next guided thread based on the {@link #guidingEvents} list. If the {@link #guidingEvent} is an instance
     * of {@link StartEvent}, it finds the guiding thread from the {@link #guidingExecutionGraph}. Otherwise, it sets the
     * {@link #guidingThread} with the thread id of the {@link #guidingEvent}. If the {@link #guidingEvent} is an instance
     * of {@link EnterMonitorEvent}, it calls the {@link #guidedEnterMonitorEventHelper(EnterMonitorEvent)} method. If the
     * {@link #guidingEvent} is an instance of {@link SuspendEvent}, it calls the {@link #guidedSuspendEventHelper(SuspendEvent)}
     * method and picks the next guided thread. Otherwise, it returns the next guided thread.
     * </p>
     *
     * @return the next guided thread that is going to be executed.
     */
    public Thread pickNextGuidedThread() {
        if (guidingEvents.isEmpty()) {
            handleEmptyGuidingEvents();
            return pickNextRandomThread();
        }

        guidingEvent = guidingEvents.remove(0);
        if (guidingEvent instanceof StartEvent) {
            guidingThread = findGuidingThreadFromStartEvent();
        } else {
            guidingThread = ((ThreadEvent) guidingEvent).getTid();
        }

        if (guidingEvent.getType() == EventType.ENTER_MONITOR) {
            guidedEnterMonitorEventHelper((EnterMonitorEvent) guidingEvent);
        }

        if (guidingEvent.getType() == EventType.SUSPEND) {
            guidedSuspendEventHelper((SuspendEvent) guidingEvent);
            return pickNextGuidedThread();
        }

        System.out.println("[Trust Strategy Message] : Thread-" +
                RuntimeEnvironment.threadObjectMap.get((long) guidingThread) + " is the next guided thread");
        return RuntimeEnvironment.threadObjectMap.get((long) guidingThread);
    }

    /**
     * Prepare the next guided enter monitor event.
     * <p>
     * This method prepares the next guided enter monitor event. It finds the thread from the
     * {@link RuntimeEnvironment#threadObjectMap} and the monitor from the {@link RuntimeEnvironment#monitorRequest}.
     * Then, it removes the pair of the thread and the monitor from the {@link RuntimeEnvironment#monitorRequest} and
     * calls the {@link #nextEnterMonitorEvent(Thread, Object)} method.
     * </p>
     *
     * @param enterMonitorEvent is the enter monitor event that is going to be executed.
     */
    private void guidedEnterMonitorEventHelper(EnterMonitorEvent enterMonitorEvent) {
        Thread thread = RuntimeEnvironment.threadObjectMap.get((long) enterMonitorEvent.getTid());
        Object monitor = RuntimeEnvironment.monitorRequest.get(thread);
        RuntimeEnvironment.monitorRequest.remove(thread, monitor);
        nextEnterMonitorEvent(thread, monitor);
    }

    /**
     * Prepare the next guided suspend event.
     * <p>
     * This method prepares the next guided suspend event. It finds the thread from the
     * {@link RuntimeEnvironment#threadObjectMap} and calls the {@link #nextSuspendEvent(Thread, Object)} method.
     * Then, by iterating through the {@link ExecutionGraph#getMCs()} , it finds the event which made the thread to suspend.
     * It then updates the {@link RuntimeEnvironment#suspendPriority} map with the the pair of the thread id of the event
     * which made the thread to suspend and the thread id of the thread which is going to be suspended, related to the monitor.
     * Finally, it calls the {@link #nextSuspendEvent(Thread, Object)} method.
     * </p>
     *
     * @param suspendEvent is the suspend event that is going to be executed.
     */
    private void guidedSuspendEventHelper(SuspendEvent suspendEvent) {
        Thread suspendThread = RuntimeEnvironment.threadObjectMap.get((long) suspendEvent.getTid());
        suspendThread(suspendThread);

        Set<Pair<Event, Event>> mcs = guidingExecutionGraph.getMCs();
        ThreadEvent firstThreadEvent = null;
        for (Pair<Event, Event> mc : mcs) {
            if (mc.component2().equals(suspendEvent)) {
                firstThreadEvent = (ThreadEvent) mc.component1();
                break;
            }
        }

        Object monitor = RuntimeEnvironment.monitorRequest.get(suspendThread);
        if (!RuntimeEnvironment.suspendPriority.containsKey(monitor)) {
            RuntimeEnvironment.suspendPriority.put(monitor, new HashSet<>());
        }

        RuntimeEnvironment.suspendPriority.get(monitor).add(new Pair<>((long) firstThreadEvent.getTid(), (long) suspendEvent.getTid()));
        nextSuspendEvent(suspendThread, monitor);
    }

    /**
     * Finds the guiding thread from the start event.
     * <p>
     * This method finds the guiding thread from the start event. It returns the thread id of the start event that is
     * available in the {@link #guidingExecutionGraph}.
     * </p>
     *
     * @return the thread id of the start event.
     */
    private int findGuidingThreadFromStartEvent() {
        return guidingExecutionGraph.getSTs().stream()
                .filter(pair -> pair.component2().equals(guidingEvent))
                .map(pair -> ((ThreadEvent) pair.component1()).getTid())
                .findFirst()
                .orElse(0);
    }

    /**
     * Handles the empty guiding events.
     * <p>
     * This method handles the empty guiding events. It prints a message that the guiding events is empty and finds the
     * new COs, STs, JTs, MCs, and TCs based on the current graph. Then, it sets the {@link #guidingActivate} to false.
     * </p>
     */
    private void handleEmptyGuidingEvents() {
        System.out.println("[Trust Strategy Message] : The guidingEvents is empty");
        currentGraph.setCOs(findNewCOs());
        currentGraph.setSTs(findNewSTs());
        currentGraph.setJTs(findNewJTs());
        currentGraph.setMCs(findNewMCs());
        currentGraph.setTCs(findNewTCs());
        currentGraph.setPCs(findNewPCs());
        guidingActivate = false;
    }

    /**
     * Makes a new copy of the COs.
     * <p>
     * This method makes a new copy of the current graph's COs. It iterates over the {@link ExecutionGraph#getCOs()} of
     * the {@link #guidingExecutionGraph} and finds the new COs based on the current graph. It returns the new COs.
     * </p>
     *
     * @return the new COs based on the current graph.
     */
    private List<CO> findNewCOs() {
        List<CO> newCOs = new ArrayList<>();
        for (CO co : guidingExecutionGraph.getCOs()) {
            ReadsFrom firstWrite;
            WriteEvent secondWrite;

            if (co.getFirstWrite() instanceof InitializationEvent) {
                firstWrite = (ReadsFrom) currentGraph.getGraphEvents().get(0);
            } else {
                firstWrite = findWriteEvent((WriteEvent) co.getFirstWrite());
            }
            secondWrite = findWriteEvent(co.getSecondWrite());

            if (firstWrite != null && secondWrite != null) {
                newCOs.add(new CO(firstWrite, secondWrite));
            }
        }
        return newCOs;
    }

    /**
     * Finds the write event based on the current graph.
     * <p>
     * This method finds the write event based on the current graph. It returns the write event that is available in the
     * {@link #currentGraph}.
     * </p>
     *
     * @param tempWrite is the write event that is going to be found.
     * @return the write event that is available in the current graph.
     */
    private WriteEvent findWriteEvent(WriteEvent tempWrite) {
        return currentGraph.getGraphEvents().stream()
                .filter(event -> event instanceof WriteEvent)
                .map(event -> (WriteEvent) event)
                .filter(writeEvent -> writeEvent.getTid() == tempWrite.getTid() &&
                        writeEvent.getSerial() == tempWrite.getSerial())
                .findFirst()
                .orElse(null);
    }

    /**
     * Makes a new copy of the STs.
     * <p>
     * This method makes a new copy of the current graph's STs. It iterates over the {@link ExecutionGraph#getSTs()} of
     * the {@link #guidingExecutionGraph} and finds the new STs based on the current graph. It returns the new STs.
     * </p>
     *
     * @return the new STs based on the current graph.
     */
    private Set<Pair<Event, Event>> findNewSTs() {
        Set<Pair<Event, Event>> newSTs = new HashSet<>();
        for (Pair<Event, Event> st : guidingExecutionGraph.getSTs()) {
            ThreadEvent firstThreadEvent = findThreadEventInCurrentGraph((ThreadEvent) st.component1());
            ThreadEvent secondThreadEvent = findThreadEventInCurrentGraph((ThreadEvent) st.component2());
            if (firstThreadEvent != null && secondThreadEvent != null) {
                newSTs.add(new Pair<>(firstThreadEvent, secondThreadEvent));
            }
        }
        return newSTs;
    }

    /**
     * Makes a new copy of the MCs.
     * <p>
     * This method makes a new copy of the current graph's MCs. It iterates over the {@link ExecutionGraph#getMCs()} of
     * the {@link #guidingExecutionGraph} and finds the new MCs based on the current graph. It returns the new MCs.
     * </p>
     *
     * @return the new MCs based on the current graph.
     */
    private Set<Pair<Event, Event>> findNewMCs() {
        Set<Pair<Event, Event>> newMCs = new HashSet<>();
        for (Pair<Event, Event> mc : guidingExecutionGraph.getMCs()) {
            ThreadEvent firstThreadEvent = findThreadEventInCurrentGraph((ThreadEvent) mc.component1());
            ThreadEvent secondThreadEvent = findThreadEventInCurrentGraph((ThreadEvent) mc.component2());
            if (firstThreadEvent != null && secondThreadEvent != null) {
                newMCs.add(new Pair<>(firstThreadEvent, secondThreadEvent));
            }
        }
        return newMCs;
    }

    /**
     * Makes a new copy of the TCs.
     * <p>
     * This method makes a new copy of the current graph's TCs. It iterates over the {@link ExecutionGraph#getTCs()} of
     * the {@link #guidingExecutionGraph} and finds the new TCs based on the current graph. It returns the new TCs.
     * </p>
     *
     * @return the new TCs based on the current graph.
     */
    private Set<Pair<Event, Event>> findNewTCs() {
        Set<Pair<Event, Event>> newTCs = new HashSet<>();
        for (Pair<Event, Event> tc : guidingExecutionGraph.getTCs()) {
            ThreadEvent firstThreadEvent = findThreadEventInCurrentGraph((ThreadEvent) tc.component1());
            ThreadEvent secondThreadEvent = findThreadEventInCurrentGraph((ThreadEvent) tc.component2());
            if (firstThreadEvent != null && secondThreadEvent != null) {
                newTCs.add(new Pair<>(firstThreadEvent, secondThreadEvent));
            }
        }
        return newTCs;
    }

    /**
     * Makes a new copy of the PCs.
     * <p>
     * This method makes a new copy of the current graph's PCs. It iterates over the {@link ExecutionGraph#getPCs()} of
     * the {@link #guidingExecutionGraph} and finds the new PCs based on the current graph. It returns the new PCs.
     * </p>
     *
     * @return the new PCs based on the current graph.
     */
    private Set<Pair<Event, Event>> findNewPCs() {
        Set<Pair<Event, Event>> newPCs = new HashSet<>();
        for (Pair<Event, Event> pc : guidingExecutionGraph.getPCs()) {
            ThreadEvent firstThreadEvent = findThreadEventInCurrentGraph((ThreadEvent) pc.component1());
            ThreadEvent secondThreadEvent = findThreadEventInCurrentGraph((ThreadEvent) pc.component2());
            if (firstThreadEvent != null && secondThreadEvent != null) {
                newPCs.add(new Pair<>(firstThreadEvent, secondThreadEvent));
            }
        }
        return newPCs;
    }

    /**
     * Finds the thread event based on the current graph.
     * <p>
     * This method finds the thread event based on the current graph. It returns the thread event that is available in the
     * {@link #currentGraph}.
     * </p>
     *
     * @param tempThreadEvent is the thread event that is going to be found.
     * @return the thread event that is available in the current graph.
     */
    private ThreadEvent findThreadEventInCurrentGraph(ThreadEvent tempThreadEvent) {
        return currentGraph.getGraphEvents().stream()
                .filter(event -> event instanceof ThreadEvent)
                .map(event -> (ThreadEvent) event)
                .filter(threadEvent -> threadEvent.getTid() == tempThreadEvent.getTid() &&
                        threadEvent.getSerial() == tempThreadEvent.getSerial() &&
                        threadEvent.getType() == tempThreadEvent.getType())
                .findFirst()
                .orElse(null);
    }

    /**
     * Makes a new copy of the JTs.
     * <p>
     * This method makes a new copy of the current graph's JTs. It iterates over the {@link ExecutionGraph#getJTs()} of
     * the {@link #guidingExecutionGraph} and finds the new JTs based on the current graph. It returns the new JTs.
     * </p>
     *
     * @return the new JTs based on the current graph.
     */
    private Set<Pair<Event, Event>> findNewJTs() {
        Set<Pair<Event, Event>> newJTs = new HashSet<>();
        for (Pair<Event, Event> jt : guidingExecutionGraph.getJTs()) {
            ThreadEvent firstThreadEvent = findThreadEventInCurrentGraph((ThreadEvent) jt.component1());
            ThreadEvent secondThreadEvent = findThreadEventInCurrentGraph((ThreadEvent) jt.component2());
            if (firstThreadEvent != null && secondThreadEvent != null) {
                newJTs.add(new Pair<>(firstThreadEvent, secondThreadEvent));
            }
        }
        return newJTs;
    }

    /**
     * Picks the next thread.
     * <p>
     * This method picks the next thread that is going to be executed. It returns the next guided thread if the
     * {@link #guidingActivate} is true. Otherwise, it returns the next random thread.
     * </p>
     *
     * @return the next thread that is going to be executed.
     */
    @Override
    public Thread pickNextThread() {
        if (guidingActivate) {
            return pickNextGuidedThread();
        } else {
            return pickNextRandomThread();
        }
    }

    /**
     * Indicates whether the execution is done or not.
     * <p>
     * This method indicates whether the execution is done or not. It returns true if the
     * {@link RuntimeEnvironment#mcGraphs} is empty. Otherwise, it returns false.
     * </p>
     *
     * @return true if the execution is done, otherwise false.
     */
    @Override
    public boolean done() {
        return RuntimeEnvironment.mcGraphs.isEmpty();
    }

    /**
     * Saves the execution graphs to a file.
     * <p>
     * This method saves the execution graphs to a file. It creates a new file with the given file name and writes the
     * execution graphs to the file.
     * </p>
     *
     * @param executionGraphs is the list of execution graphs that are going to be saved.
     * @param fileName        is the name of the file that is going to be created.
     * @throws IllegalArgumentException if the execution graphs or the file name is null.
     * @throws RuntimeException         if an error occurred while saving the graphs to the file.
     */
    public void saveGraphsToFile(List<ExecutionGraph> executionGraphs, String fileName) {
        if (executionGraphs == null || fileName == null) {
            throw new IllegalArgumentException("Arguments cannot be null");
        }

        try (FileOutputStream fileOut = new FileOutputStream(fileName);
             ObjectOutputStream out = new ObjectOutputStream(fileOut)) {
            out.writeObject(executionGraphs);
        } catch (IOException e) {
            throw new RuntimeException("Error occurred while saving graphs to file", e);
        }
    }

    /**
     * Loads the execution graphs from a file.
     * <p>
     * This method loads the execution graphs from a file. It reads the execution graphs from the file and returns the
     * loaded graphs.
     * </p>
     *
     * @param fileName is the name of the file that is going to be read.
     * @return the loaded execution graphs.
     * @throws IllegalArgumentException if the file name is null or empty.
     * @throws RuntimeException         if an error occurred while loading the graphs from the file.
     */
    @SuppressWarnings("unchecked")
    public List<ExecutionGraph> loadGraphsFromFile(String fileName) {
        if (fileName == null || fileName.isEmpty()) {
            throw new IllegalArgumentException("File name cannot be null or empty");
        }

        List<ExecutionGraph> loadedGraphs;

        try (FileInputStream fileIn = new FileInputStream(fileName);
             ObjectInputStream in = new ObjectInputStream(fileIn)) {
            Object object = in.readObject();
            if (object instanceof List) {
                loadedGraphs = (List<ExecutionGraph>) object;
            } else {
                throw new RuntimeException("The object is not an instance of List");
            }
        } catch (IOException i) {
            throw new RuntimeException("Error occurred while loading graphs from file", i);
        } catch (ClassNotFoundException c) {
            throw new RuntimeException("Class not found while loading graphs from file", c);
        }

        return loadedGraphs;
    }

    /**
     * Saves the buggy execution trace.
     * <p>
     * This method saves the buggy execution trace. It writes the {@link RuntimeEnvironment#eventsRecord} to the file.
     * </p>
     */
    @Override
    public void saveBuggyExecutionTrace() {
        try {
            FileOutputStream fileOut = new FileOutputStream(buggyTracePath + buggyTraceFile);
            ObjectOutputStream out = new ObjectOutputStream(fileOut);
            out.writeObject(RuntimeEnvironment.eventsRecord);
            out.close();
            fileOut.close();
            System.out.println("[Trust Strategy Message] : Buggy execution trace is saved in " + buggyTracePath +
                    buggyTraceFile);
        } catch (IOException i) {
            i.printStackTrace();
        }
    }

    /**
     * Saves the execution state.
     * <p>
     * This method saves the execution state. It saves the {@link #mcGraphs} to the file and loads the saved graphs
     * to the {@link RuntimeEnvironment#mcGraphs} list. It also sets the {@link RuntimeEnvironment#numOfGraphs}
     * with the number of graphs that are available in the {@link Trust#getGraphCounter()}.
     * </p>
     */
    @Override
    public void saveExecutionState() {
        if (!mcGraphs.isEmpty()) {
            RuntimeEnvironment.mcGraphs.addAll(mcGraphs);
        }
        RuntimeEnvironment.numOfGraphs = trust.getGraphCounter();
    }


    /**
     * Analyzes suspended threads to make them unsuspend if possible.
     * <p>
     * This methods analyzes the suspended threads to make them unsuspend if possible. First, it updates the
     * {@link RuntimeEnvironment#suspendPriority} map by calling the {@link #updateSuspendPriority(Object, Thread)} method.
     * Then, it finds the candidate threads for being unsuspended by calling the {@link #findSuspendedThreads(Object)}
     * method. It also finds the forbidden threads for being unsuspended by calling the {@link #findForbiddenThreads(Object)}
     * method. Finally, it unsuspends the candidate threads if they are not in the forbidden threads list.
     * </p>
     *
     * @param monitor is the monitor that some threads might be suspended for it.
     * @param thread  is the thread that might be suspended other threads for the monitor.
     */
    private void analyzeSuspendedThreadsForMonitor(Object monitor, Thread thread) {
        updateSuspendPriority(monitor, thread);
        List<Thread> candidateThreads = findSuspendedThreads(monitor);
        //System.out.println("[Debugging Message] : The candidate threads for resuming are : ");
        //candidateThreads.forEach(t -> System.out.println("Thread-" + RuntimeEnvironment.threadIdMap.get(t.getId())));
        List<Thread> forbiddenThreads = findForbiddenThreads(monitor);
        //System.out.println("[Debugging Message] : The forbidden threads for resuming are : ");
        //forbiddenThreads.forEach(t -> System.out.println("Thread-" + RuntimeEnvironment.threadIdMap.get(t.getId())));
        if (!candidateThreads.isEmpty()) {
            for (Thread t : candidateThreads) {
                if (!forbiddenThreads.contains(t)) {
                    //System.out.println("[Debugging Message] : Thread-" + RuntimeEnvironment.threadIdMap.get(t.getId()) +
                    //        " is going to be unsuspended");
                    unsuspendThread(t);
                }
            }
        }
    }

    /**
     * Updates the suspend priority map.
     * <p>
     * This method removes the pairs from the {@link RuntimeEnvironment#suspendPriority} for the given existing monitor
     * as a key, if the first element of the pairs is equal to the thread id of the given thread.
     * </p>
     *
     * @param monitor is the monitor that some threads might be suspended for it.
     * @param thread  is the thread that might be suspended other threads for the monitor.
     */
    private void updateSuspendPriority(Object monitor, Thread thread) {
        if (RuntimeEnvironment.suspendPriority.containsKey(monitor)) {
            RuntimeEnvironment.suspendPriority.get(monitor).removeIf(pair -> pair.component1().equals(RuntimeEnvironment.threadIdMap.get(thread.getId())));
        }
    }

    /**
     * Finds the list of threads which are forbidden to be unsuspended
     * <p>
     * This method finds the list of threads which are forbidden to be unsuspended. It iterates over the pairs of the
     * existing monitor key from the {@link RuntimeEnvironment#suspendPriority}. For each pair, it collects the second
     * component of the pair, which is the thread id of the thread that is forbidden to be unsuspended.
     * </p>
     *
     * @param monitor is the monitor that some threads might be suspended for it.
     * @return the list of threads which are forbidden to be unsuspended.
     */
    private List<Thread> findForbiddenThreads(Object monitor) {
        List<Thread> forbiddenThreads = new ArrayList<>();
        if (RuntimeEnvironment.suspendPriority.containsKey(monitor)) {
            // Find all the second elements of the pairs in the set of pairs, corresponding to the monitor, and add them
            // to the forbidden threads list.
            forbiddenThreads = RuntimeEnvironment.suspendPriority.get(monitor).stream()
                    .map(pair -> RuntimeEnvironment.threadObjectMap.get(pair.component2()))
                    .collect(Collectors.toList());
        }
        return forbiddenThreads;
    }
}