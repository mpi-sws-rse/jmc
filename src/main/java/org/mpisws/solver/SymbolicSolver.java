package org.mpisws.solver;

import org.mpisws.symbolic.*;
import org.sosy_lab.common.ShutdownManager;
import org.sosy_lab.common.configuration.Configuration;
import org.sosy_lab.common.configuration.InvalidConfigurationException;
import org.sosy_lab.common.log.BasicLogManager;
import org.sosy_lab.common.log.LogManager;
import org.sosy_lab.java_smt.SolverContextFactory;
import org.sosy_lab.java_smt.api.*;
import org.sosy_lab.java_smt.api.NumeralFormula.IntegerFormula;

import java.util.*;

/**
 * The SymbolicSolver class is a core component designed for solving symbolic formulas within the program under the test.
 * It encapsulates the functionality for manipulating and solving symbolic representations of boolean and integer
 * variables. This class leverages the JavaSMT API to interface with various SMT (Satisfiability Modulo Theories) solvers,
 * providing a unified API for theorem proving tasks.
 * <p>
 * The class supports operations such as solving symbolic formulas, negating formulas, and creating dependency formulas
 * from a list of symbolic operations. It allows for the dynamic selection of SMT solvers based on the provided solver type,
 * enabling flexibility in choosing the underlying solver based on the specific requirements of the verification task.
 * <p>
 * SymbolicSolver initializes with a configuration, a logging manager, and a shutdown manager to handle the lifecycle
 * of the solver context. It provides methods to access and manipulate symbolic variables (both boolean and integer),
 * facilitating the creation of complex symbolic expressions that can be used by programmer.
 */
abstract public class SymbolicSolver {

    /**
     * @property {@link #config} used to store the configuration settings for the solver context.
     */
    private Configuration config;

    /**
     * @property {@link #logger} used to manage logging and output messages from the solver.
     */
    private LogManager logger;

    /**
     * @property {@link #shutdown} used to manage the shutdown and cleanup of the solver context.
     */
    private ShutdownManager shutdown;

    /**
     * @property {@link #symIntVariableMap} used to store the mapping of symbolic integer variables to their names.
     */
    public Map<String, SymIntVariable> symIntVariableMap = new HashMap<>();

    /**
     * @property {@link #symBoolVariableMap} used to store the mapping of symbolic boolean variables to their names.
     */
    public Map<String, SymBoolVariable> symBoolVariableMap = new HashMap<>();

    /**
     * @property {@link #context} used to store the solver context for interacting with the SMT solver.
     */
    protected SolverContext context;

    /**
     * @property {@link #fmgr} used to access the formula manager for creating and manipulating formulas.
     */
    protected FormulaManager fmgr;

    /**
     * @property {@link #bmgr} used to access the boolean formula manager for boolean operations.
     */
    protected BooleanFormulaManager bmgr;

    /**
     * @property {@link #imgr} used to access the integer formula manager for integer operations.
     */
    protected IntegerFormulaManager imgr;

    /**
     * @property {@link #model} used to store the model generated by the solver for a satisfiable formula.
     */
    protected Model model;

    public boolean bothSatUnsat = false;

    public boolean resetProver = false;

    public Stack<BooleanFormula> stack = new Stack<>();

    /**
     * Constructs a new instance of the SymbolicSolver class with the default SMT solver type (SMTInterpol).
     */
    public SymbolicSolver() {
        try {
            config = Configuration.builder().build();
            logger = BasicLogManager.create(config);
            shutdown = ShutdownManager.create();
            context = SolverContextFactory.createSolverContext(
                    config, logger, shutdown.getNotifier(), SolverContextFactory.Solvers.SMTINTERPOL
            );
            fmgr = context.getFormulaManager();
            bmgr = fmgr.getBooleanFormulaManager();
            imgr = fmgr.getIntegerFormulaManager();
        } catch (InvalidConfigurationException e) {
            e.printStackTrace();
        }
    }

    /**
     * Constructs a new instance of the SymbolicSolver class with the specified SMT solver type.
     *
     * @param type the type of SMT solver to use for solving symbolic formulas.
     */
    public SymbolicSolver(SMTSolverTypes type) {
        SolverContextFactory.Solvers solverType = findSolverType(type);
        try {
            config = Configuration.builder().build();
            logger = BasicLogManager.create(config);
            shutdown = ShutdownManager.create();
            context = SolverContextFactory.createSolverContext(
                    config, logger, shutdown.getNotifier(), solverType
            );
            fmgr = context.getFormulaManager();
            bmgr = fmgr.getBooleanFormulaManager();
            imgr = fmgr.getIntegerFormulaManager();
        } catch (InvalidConfigurationException e) {
            e.printStackTrace();
        }
    }

    public int size() {
        return 0;
    }

    /**
     * Finds the corresponding SolverContextFactory.Solvers enum value for the given SMTSolverTypes enum value.
     *
     * @param type the type of SMT solver to find the corresponding enum value for.
     * @return the corresponding SolverContextFactory.Solvers enum value.
     */
    public SolverContextFactory.Solvers findSolverType(SMTSolverTypes type) {
        return switch (type) {
            case OPENSMT -> SolverContextFactory.Solvers.OPENSMT;
            case MATHSAT5 -> SolverContextFactory.Solvers.MATHSAT5;
            case SMTINTERPOL -> SolverContextFactory.Solvers.SMTINTERPOL;
            case Z3 -> SolverContextFactory.Solvers.Z3;
            case PRINCESS -> SolverContextFactory.Solvers.PRINCESS;
            case BOOLECTOR -> SolverContextFactory.Solvers.BOOLECTOR;
            case CVC4 -> SolverContextFactory.Solvers.CVC4;
            case CVC5 -> SolverContextFactory.Solvers.CVC5;
            case YICES2 -> SolverContextFactory.Solvers.YICES2;
            default -> SolverContextFactory.Solvers.SMTINTERPOL;
        };
    }

    /**
     * Solves the given symbolic formula and returns the result.
     *
     * @param operation the symbolic operation containing the formula to solve.
     * @return true if the formula is satisfiable, false otherwise.
     */
    public boolean solveSymbolicFormula(SymbolicOperation operation) {
        return solver(operation.getFormula());
    }

    /**
     * Dissolves the given symbolic formula and returns the result.
     *
     * @param operation the symbolic operation containing the formula to dissolve.
     * @return true if the formula is unsatisfiable, false otherwise.
     */
    public boolean disSolveSymbolicFormula(SymbolicOperation operation) {
        return solver(negateFormula(operation.getFormula()));
    }

    /**
     * Solves the symbolic operation with conjunction of the given dependency operation and returns the result.
     *
     * @param operation           the symbolic operation needs to be solved.
     * @param dependencyOperation the dependency operation which the operation depends on.
     * @return true if the dependent formulas are satisfiable, false otherwise.
     */
    public boolean solveDependentSymbolicFormulas(SymbolicOperation operation, SymbolicOperation dependencyOperation) {
        BooleanFormula contextFormula = bmgr.and(operation.getFormula(), dependencyOperation.getFormula());
        return solver(contextFormula);
    }

    /**
     * Dissolves the symbolic operation with conjunction of the given dependency operation and returns the result.
     *
     * @param operation           the symbolic operation needs to be dissolved.
     * @param dependencyOperation the dependency operation which the operation depends on.
     * @return true if the dependent formulas are unsatisfiable, false otherwise.
     */
    public boolean disSolveDependentSymbolicFormulas(SymbolicOperation operation, SymbolicOperation dependencyOperation) {
        BooleanFormula contextFormula = bmgr.and(negateFormula(operation.getFormula()), dependencyOperation.getFormula());
        return solver(contextFormula);
    }

    /**
     * Negates the given boolean formula and returns the result.
     *
     * @param formula the boolean formula to negate.
     * @return the negated boolean formula.
     */
    public BooleanFormula negateFormula(BooleanFormula formula) {
        return bmgr.not(formula);
    }

    /**
     * Creates a dependency formula from the given list of boolean formulas.
     *
     * @param formulas the list of boolean formulas to create the dependency formula from.
     * @return the dependency formula created from the list of boolean formulas.
     */
    public BooleanFormula makeDependencyFormula(List<BooleanFormula> formulas) {
        BooleanFormula dependencyFormula;
        if (formulas.size() == 1) {
            dependencyFormula = formulas.get(0);
        } else {
            dependencyFormula = formulas.get(0);
            for (int i = 1; i < formulas.size(); i++) {
                dependencyFormula = bmgr.and(dependencyFormula, formulas.get(i));
            }
        }
        return dependencyFormula;
    }

    /**
     * Creates a dependency operation from the given list of symbolic operations.
     *
     * @param operations the list of symbolic operations to create the dependency operation from.
     * @return the dependency operation created from the list of symbolic operations.
     */
    public SymbolicOperation makeDependencyOperation(List<SymbolicOperation> operations) {
        SymbolicOperation dependencyOperation = new SymbolicOperation();
        BooleanFormula dependencyFormula;
        if (operations.size() == 1) {
            dependencyFormula = operations.get(0).getFormula();
        } else {
            dependencyFormula = operations.get(0).getFormula();
            for (int i = 1; i < operations.size(); i++) {
                dependencyFormula = bmgr.and(dependencyFormula, operations.get(i).getFormula());
            }
        }
        dependencyOperation.setFormula(dependencyFormula);
        //System.out.println("[Debugging Message] : Dependency Operation: " + dependencyOperation.getFormula().toString());
        return dependencyOperation;
    }

    /**
     * Picks the result of the symbolic operation.
     *
     * @param sat   is the satisfiability of the symbolic operation.
     * @param unSat is the unsatisfiability of the symbolic operation.
     * @return true if the symbolic operation is satisfiable, otherwise false.
     */
    protected boolean pickSatOrUnsat(boolean sat, boolean unSat) {
        if (sat && unSat) {
//            System.out.println("[Symbolic Solver Message] : Both SAT and UNSAT are possible for the symbolic " +
//                    "arithmetic operation");
            return new Random().nextBoolean();
        } else if (sat) {
//            System.out.println("[Symbolic Solver Message] : Only SAT is possible for the symbolic arithmetic " +
//                    "operation");
            return true;
        } else if (unSat) {
//            System.out.println("[Symbolic Solver Message] : Only UNSAT is possible for the symbolic arithmetic " +
//                    "operation");
            return false;
        } else {
            System.out.println("[Symbolic Solver Message] : No solution is found for the symbolic arithmetic " +
                    "operation");
            System.exit(0);
            return false;
        }
    }

    /**
     * Solves the given boolean formula and returns the result.
     * <p>
     * This method creates a new prover environment, adds the boolean formula as a constraint, and checks if the formula
     * is satisfiable. If the formula is satisfiable, the model generated by the solver is stored in the model property.
     * The method returns true if the formula is satisfiable, and false otherwise.
     * </p>
     *
     * @param formula the boolean formula to solve.
     * @return true if the formula is satisfiable, false otherwise.
     */

    protected abstract boolean solver(BooleanFormula formula);

    public Configuration getConfig() {
        return config;
    }

    public LogManager getLogger() {
        return logger;
    }

    public ShutdownManager getShutdown() {
        return shutdown;
    }

    public Map<String, SymIntVariable> getSymIntVariableMap() {
        return symIntVariableMap;
    }

    public SolverContext getContext() {
        return context;
    }

    public FormulaManager getFmgr() {
        return fmgr;
    }

    public BooleanFormulaManager getBmgr() {
        return bmgr;
    }

    public IntegerFormulaManager getImgr() {
        return imgr;
    }

    public Model getModel() {
        return model;
    }

    /**
     * Returns the symbolic integer variable with the given name.
     * <p>
     * This method checks if the symbolic integer variable with the given name already exists in the symIntVariableMap.
     * If the variable exists, it returns the existing variable. Otherwise, it creates a new symbolic integer variable
     * with the given name, stores it in the symIntVariableMap, and returns the new variable.
     * </p>
     *
     * @param name the name of the symbolic integer variable to retrieve.
     * @return the symbolic integer variable with the given name.
     */
    public SymIntVariable getSymIntVariable(String name) {
        if (symIntVariableMap.containsKey(name)) {
            //System.out.println("[Symbolic Solver Message] Returning existing SymIntVariable: " + name);
            return symIntVariableMap.get(name);
        } else {
            //System.out.println("[Symbolic Solver Message] Creating new SymIntVariable: " + name);
            IntegerFormula symInt = imgr.makeVariable(name);
            SymIntVariable variable = new SymIntVariable(symInt);
            symIntVariableMap.put(name, variable);
            return variable;
        }
    }

    public int getSymIntVarValue(String name) {
        if (symIntVariableMap.containsKey(name)) {
            return symIntVariableMap.get(name).getValue();
        } else {
            throw new IllegalArgumentException("[Symbolic Solver Message] Symbolic integer variable not found: " + name);
        }
    }

    /**
     * Returns the symbolic boolean variable with the given name.
     * <p>
     * This method checks if the symbolic boolean variable with the given name already exists in the symBoolVariableMap.
     * If the variable exists, it returns the existing variable. Otherwise, it creates a new symbolic boolean variable
     * with the given name, stores it in the symBoolVariableMap, and returns the new variable.
     * </p>
     *
     * @param name the name of the symbolic boolean variable to retrieve.
     * @return the symbolic boolean variable with the given name.
     */
    public SymBoolVariable getSymBoolVariable(String name) {
        if (symBoolVariableMap.containsKey(name)) {
            //System.out.println("Returning existing SymBoolVariable: " + name);
            return symBoolVariableMap.get(name);
        } else {
            //System.out.println("Creating new SymBoolVariable: " + name);
            BooleanFormula symBool = bmgr.makeVariable(name);
            SymBoolVariable variable = new SymBoolVariable(symBool);
            symBoolVariableMap.put(name, variable);
            return variable;
        }
    }

    public boolean getSymBoolVarValue(String name) {
        if (symBoolVariableMap.containsKey(name)) {
            return symBoolVariableMap.get(name).getValue();
        } else {
            throw new IllegalArgumentException("[Symbolic Solver Message] Symbolic boolean variable not found: " + name);
        }
    }

    public BooleanFormula pop() {
        return null;
    }

//    public void pop() {
//
//    }

    public void push() {

    }

    public void push(BooleanFormula formula) {

    }

    public void push(SymbolicOperation operation) {

    }

    public abstract void computeNewSymbolicOperationRequest(SymbolicOperation symbolicOperation);

    public abstract void computeNewSymAssumeOperationRequest(SymbolicOperation symbolicOperation);

    public abstract void computeGuidedSymAssumeOperationRequest(SymbolicOperation symbolicOperation);

    public abstract void computeNewSymbolicAssertOperationRequest(SymbolicOperation symbolicOperation);

    public abstract void computeGuidedSymbolicAssertOperationRequest(SymbolicOperation symbolicOperation);

    public abstract void updatePathSymbolicOperations(SymbolicOperation symbolicOperation);

    public abstract void solveAndUpdateModelSymbolicVariables();

    public abstract void computeRandomlyNewSymbolicOperationRequest(SymbolicOperation symbolicOperation);

    public abstract void resetProver();

    public abstract ProverState createNewProver();

    public abstract void setProver(ProverEnvironment prover, int proverId);

    public abstract void setProver(ProverState proverState, int proverId);

    public abstract void setProver(ProverEnvironment prover, Stack<BooleanFormula> stack, int proverId);

    public abstract int getProverId();

    public void resetProver(ProverEnvironment prover) {

    }
}