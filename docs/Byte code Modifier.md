## Instrumentation

The instrumentation consists of modifying Byte-code generated by compiling a target. In addition to the target, the instrumentation will also compile and modify the Byte-code of certain JMC files. Specifically, the files of the following packages are instrumented.

1. `org.mpisws.runtime` - Contains the [[Runtime]]
2. `org.mpisws.checker` - Contains the [[ModelChecker]]
3. `org.mpisws.chceker.strategy` - Contains the model checking [[Scheduler#Strategies]]
4. `org.mpisws.symbolic` - Contains the [[Symbolic execution engine]]
5. `org.mpisws.solver` - Contains a generic SMT solver used by the Symbolic execution engine
6. `org.mpisws.util.concurrent` - Contains [[Concurrent primitives]] that needs to be inserted by the instrumentation engine.

### Instrumentation Engine

Given the Byte-code, the instrumentation engine (represented by the `ByteCodeModifier` class) walks through the code to insert calls to the runtime. Additionally, the instrumentation replaces certain calls to concurrent primitives by using the one custom built to be compatible with the Runtime.

Based on the program type (Shared Memory/Message passing), a set of the following methods will be invoked.

| Method                     | Description                                                                                                                                                                                | SharedMem/<br>MessagePassing |
| -------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------- |
| `modifySyncMethod`         | Updates Synchronized methods. ([[Synchronized method instrumentation]])                                                                                                                    | SharedMem                    |
| `modifySymbolicEval`       | Inserts calls to Runtime whenever [[Symbolic execution engine#Symbolic Methods]] are called.<br>([[Symbolic instrumentation]])                                                             | SharedMem                    |
| `modifyParkAndUnpark`      | Replaces calls to `LockSupport` using a custom instrumentation.<br>([[Park and Unpark Instrumentation]])                                                                                   | Both                         |
| `modifyExecutors`          | `java.util.concurrent.Executors` calls are updated. (?) ([[Executors Instrumentation]])                                                                                                    | Both                         |
| `modifyThreadCreation`     | Every instance of thread creation is updated with calls to the Runtime `addThread` method.<br>([[Thread Instrumentation]])                                                                 | SharedMem                    |
| `modifyThreadStart`        | At every invocation of `thread.start()`, we insert a call to `Runtime.threadStart`<br>([[Thread Instrumentation]])                                                                         | Both                         |
| `modifyThreadRun`          | Each `run` method of a thread is modified to invoke `Runtime.waitRequest`<br>([[Thread Instrumentation]])                                                                                  | Both                         |
| `modifyReadWriteOperation` | All `GETFIELD` and `PUTFIELD` instructions in the byte-code and instrumented with a `Runtime.readOperation` and `Runtime.writeOperation` respectively.<br>([[Read write Instrumentation]]) | SharedMem                    |
| `modifyMonitorStatements`  | Update `MONITORENTER` and `MONITOREXIT` statements with calls to locks in the runtime.<br>([[Monitor Instrumentation]])                                                                    | SharedMem                    |
| `modifyAssert`             | For every `assertion`, the modifier inserts a call to the `Runtime.assertOperation` within a try-catch block.<br>([[Assert Instrumentation]])                                              | Both                         |
| `modifyThreadJoin`         | `thread.join()` calls are preceded by calls to `Runtime.threadJoin`<br>([[Thread Instrumentation]])                                                                                        | Both                         |
| `addRuntimeEnvironment`    | The main method of the target is updated to initialize the [[Runtime]] and [[Scheduler]]<br>([[Runtime Instrumentation]])                                                                  | Both                         |

### Pending Tasks

1. The instrumentation makes multiple passes over all the byte code for each modification. Instead, a single pass should be made over the byte code. 
2. The entire Byte-code is loaded in memory. In addition to the JVM doing so. Furthermore, it is unclear if the memory contains duplicates since multiple passes are made through the byte code. Moving to an annotation processor might solve this problem
3. Why not instrument irrespective of the program type? Alternatively, we can infer the program type.

## Invoke Main